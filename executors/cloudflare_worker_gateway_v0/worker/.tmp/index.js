var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });

// node_modules/@cfworker/json-schema/dist/deep-compare-strict.js
function deepCompareStrict(a, b) {
  const typeofa = typeof a;
  if (typeofa !== typeof b) {
    return false;
  }
  if (Array.isArray(a)) {
    if (!Array.isArray(b)) {
      return false;
    }
    const length = a.length;
    if (length !== b.length) {
      return false;
    }
    for (let i = 0; i < length; i++) {
      if (!deepCompareStrict(a[i], b[i])) {
        return false;
      }
    }
    return true;
  }
  if (typeofa === "object") {
    if (!a || !b) {
      return a === b;
    }
    const aKeys = Object.keys(a);
    const bKeys = Object.keys(b);
    const length = aKeys.length;
    if (length !== bKeys.length) {
      return false;
    }
    for (const k of aKeys) {
      if (!deepCompareStrict(a[k], b[k])) {
        return false;
      }
    }
    return true;
  }
  return a === b;
}
__name(deepCompareStrict, "deepCompareStrict");

// node_modules/@cfworker/json-schema/dist/pointer.js
function encodePointer(p) {
  return encodeURI(escapePointer(p));
}
__name(encodePointer, "encodePointer");
function escapePointer(p) {
  return p.replace(/~/g, "~0").replace(/\//g, "~1");
}
__name(escapePointer, "escapePointer");

// node_modules/@cfworker/json-schema/dist/dereference.js
var schemaArrayKeyword = {
  prefixItems: true,
  items: true,
  allOf: true,
  anyOf: true,
  oneOf: true
};
var schemaMapKeyword = {
  $defs: true,
  definitions: true,
  properties: true,
  patternProperties: true,
  dependentSchemas: true
};
var ignoredKeyword = {
  id: true,
  $id: true,
  $ref: true,
  $schema: true,
  $anchor: true,
  $vocabulary: true,
  $comment: true,
  default: true,
  enum: true,
  const: true,
  required: true,
  type: true,
  maximum: true,
  minimum: true,
  exclusiveMaximum: true,
  exclusiveMinimum: true,
  multipleOf: true,
  maxLength: true,
  minLength: true,
  pattern: true,
  format: true,
  maxItems: true,
  minItems: true,
  uniqueItems: true,
  maxProperties: true,
  minProperties: true
};
var initialBaseURI = typeof self !== "undefined" && self.location && self.location.origin !== "null" ? new URL(self.location.origin + self.location.pathname + location.search) : new URL("https://github.com/cfworker");
function dereference(schema, lookup = /* @__PURE__ */ Object.create(null), baseURI = initialBaseURI, basePointer = "") {
  if (schema && typeof schema === "object" && !Array.isArray(schema)) {
    const id = schema.$id || schema.id;
    if (id) {
      const url = new URL(id, baseURI.href);
      if (url.hash.length > 1) {
        lookup[url.href] = schema;
      } else {
        url.hash = "";
        if (basePointer === "") {
          baseURI = url;
        } else {
          dereference(schema, lookup, baseURI);
        }
      }
    }
  } else if (schema !== true && schema !== false) {
    return lookup;
  }
  const schemaURI = baseURI.href + (basePointer ? "#" + basePointer : "");
  if (lookup[schemaURI] !== void 0) {
    throw new Error(`Duplicate schema URI "${schemaURI}".`);
  }
  lookup[schemaURI] = schema;
  if (schema === true || schema === false) {
    return lookup;
  }
  if (schema.__absolute_uri__ === void 0) {
    Object.defineProperty(schema, "__absolute_uri__", {
      enumerable: false,
      value: schemaURI
    });
  }
  if (schema.$ref && schema.__absolute_ref__ === void 0) {
    const url = new URL(schema.$ref, baseURI.href);
    url.hash = url.hash;
    Object.defineProperty(schema, "__absolute_ref__", {
      enumerable: false,
      value: url.href
    });
  }
  if (schema.$recursiveRef && schema.__absolute_recursive_ref__ === void 0) {
    const url = new URL(schema.$recursiveRef, baseURI.href);
    url.hash = url.hash;
    Object.defineProperty(schema, "__absolute_recursive_ref__", {
      enumerable: false,
      value: url.href
    });
  }
  if (schema.$anchor) {
    const url = new URL("#" + schema.$anchor, baseURI.href);
    lookup[url.href] = schema;
  }
  for (let key in schema) {
    if (ignoredKeyword[key]) {
      continue;
    }
    const keyBase = `${basePointer}/${encodePointer(key)}`;
    const subSchema = schema[key];
    if (Array.isArray(subSchema)) {
      if (schemaArrayKeyword[key]) {
        const length = subSchema.length;
        for (let i = 0; i < length; i++) {
          dereference(subSchema[i], lookup, baseURI, `${keyBase}/${i}`);
        }
      }
    } else if (schemaMapKeyword[key]) {
      for (let subKey in subSchema) {
        dereference(subSchema[subKey], lookup, baseURI, `${keyBase}/${encodePointer(subKey)}`);
      }
    } else {
      dereference(subSchema, lookup, baseURI, keyBase);
    }
  }
  return lookup;
}
__name(dereference, "dereference");

// node_modules/@cfworker/json-schema/dist/format.js
var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
var DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
var HOSTNAME = /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i;
var URIREF = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
var URITEMPLATE = /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i;
var URL_ = /^(?:(?:https?|ftp):\/\/)(?:\S+(?::\S*)?@)?(?:(?!10(?:\.\d{1,3}){3})(?!127(?:\.\d{1,3}){3})(?!169\.254(?:\.\d{1,3}){2})(?!192\.168(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u{00a1}-\u{ffff}0-9]+-?)*[a-z\u{00a1}-\u{ffff}0-9]+)(?:\.(?:[a-z\u{00a1}-\u{ffff}0-9]+-?)*[a-z\u{00a1}-\u{ffff}0-9]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu;
var UUID = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i;
var JSON_POINTER = /^(?:\/(?:[^~/]|~0|~1)*)*$/;
var JSON_POINTER_URI_FRAGMENT = /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i;
var RELATIVE_JSON_POINTER = /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/;
var FASTDATE = /^\d\d\d\d-[0-1]\d-[0-3]\d$/;
var FASTTIME = /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i;
var FASTDATETIME = /^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i;
var FASTURIREFERENCE = /^(?:(?:[a-z][a-z0-9+-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i;
var EMAIL = /* @__PURE__ */ __name((input) => {
  if (input[0] === '"')
    return false;
  const [name, host, ...rest] = input.split("@");
  if (!name || !host || rest.length !== 0 || name.length > 64 || host.length > 253)
    return false;
  if (name[0] === "." || name.endsWith(".") || name.includes(".."))
    return false;
  if (!/^[a-z0-9.-]+$/i.test(host) || !/^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+$/i.test(name))
    return false;
  return host.split(".").every((part) => /^[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?$/i.test(part));
}, "EMAIL");
var IPV4 = /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/;
var IPV6 = /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i;
var DURATION = /* @__PURE__ */ __name((input) => input.length > 1 && input.length < 80 && (/^P\d+([.,]\d+)?W$/.test(input) || /^P[\dYMDTHS]*(\d[.,]\d+)?[YMDHS]$/.test(input) && /^P([.,\d]+Y)?([.,\d]+M)?([.,\d]+D)?(T([.,\d]+H)?([.,\d]+M)?([.,\d]+S)?)?$/.test(input)), "DURATION");
function bind(r) {
  return r.test.bind(r);
}
__name(bind, "bind");
var fullFormat = {
  date,
  time: time.bind(void 0, false),
  "date-time": date_time,
  duration: DURATION,
  uri,
  "uri-reference": bind(URIREF),
  "uri-template": bind(URITEMPLATE),
  url: bind(URL_),
  email: EMAIL,
  hostname: bind(HOSTNAME),
  ipv4: bind(IPV4),
  ipv6: bind(IPV6),
  regex,
  uuid: bind(UUID),
  "json-pointer": bind(JSON_POINTER),
  "json-pointer-uri-fragment": bind(JSON_POINTER_URI_FRAGMENT),
  "relative-json-pointer": bind(RELATIVE_JSON_POINTER)
};
var fastFormat = {
  ...fullFormat,
  date: bind(FASTDATE),
  time: bind(FASTTIME),
  "date-time": bind(FASTDATETIME),
  "uri-reference": bind(FASTURIREFERENCE)
};
function isLeapYear(year) {
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}
__name(isLeapYear, "isLeapYear");
function date(str) {
  const matches = str.match(DATE);
  if (!matches)
    return false;
  const year = +matches[1];
  const month = +matches[2];
  const day = +matches[3];
  return month >= 1 && month <= 12 && day >= 1 && day <= (month == 2 && isLeapYear(year) ? 29 : DAYS[month]);
}
__name(date, "date");
function time(full, str) {
  const matches = str.match(TIME);
  if (!matches)
    return false;
  const hour = +matches[1];
  const minute = +matches[2];
  const second = +matches[3];
  const timeZone = !!matches[5];
  return (hour <= 23 && minute <= 59 && second <= 59 || hour == 23 && minute == 59 && second == 60) && (!full || timeZone);
}
__name(time, "time");
var DATE_TIME_SEPARATOR = /t|\s/i;
function date_time(str) {
  const dateTime = str.split(DATE_TIME_SEPARATOR);
  return dateTime.length == 2 && date(dateTime[0]) && time(true, dateTime[1]);
}
__name(date_time, "date_time");
var NOT_URI_FRAGMENT = /\/|:/;
var URI_PATTERN = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
function uri(str) {
  return NOT_URI_FRAGMENT.test(str) && URI_PATTERN.test(str);
}
__name(uri, "uri");
var Z_ANCHOR = /[^\\]\\Z/;
function regex(str) {
  if (Z_ANCHOR.test(str))
    return false;
  try {
    new RegExp(str, "u");
    return true;
  } catch (e) {
    return false;
  }
}
__name(regex, "regex");

// node_modules/@cfworker/json-schema/dist/ucs2-length.js
function ucs2length(s) {
  let result = 0;
  let length = s.length;
  let index = 0;
  let charCode;
  while (index < length) {
    result++;
    charCode = s.charCodeAt(index++);
    if (charCode >= 55296 && charCode <= 56319 && index < length) {
      charCode = s.charCodeAt(index);
      if ((charCode & 64512) == 56320) {
        index++;
      }
    }
  }
  return result;
}
__name(ucs2length, "ucs2length");

// node_modules/@cfworker/json-schema/dist/validate.js
function validate(instance, schema, draft = "2019-09", lookup = dereference(schema), shortCircuit = true, recursiveAnchor = null, instanceLocation = "#", schemaLocation = "#", evaluated = /* @__PURE__ */ Object.create(null)) {
  if (schema === true) {
    return { valid: true, errors: [] };
  }
  if (schema === false) {
    return {
      valid: false,
      errors: [
        {
          instanceLocation,
          keyword: "false",
          keywordLocation: instanceLocation,
          error: "False boolean schema."
        }
      ]
    };
  }
  const rawInstanceType = typeof instance;
  let instanceType;
  switch (rawInstanceType) {
    case "boolean":
    case "number":
    case "string":
      instanceType = rawInstanceType;
      break;
    case "object":
      if (instance === null) {
        instanceType = "null";
      } else if (Array.isArray(instance)) {
        instanceType = "array";
      } else {
        instanceType = "object";
      }
      break;
    default:
      throw new Error(`Instances of "${rawInstanceType}" type are not supported.`);
  }
  const { $ref, $recursiveRef, $recursiveAnchor, type: $type, const: $const, enum: $enum, required: $required, not: $not, anyOf: $anyOf, allOf: $allOf, oneOf: $oneOf, if: $if, then: $then, else: $else, format: $format, properties: $properties, patternProperties: $patternProperties, additionalProperties: $additionalProperties, unevaluatedProperties: $unevaluatedProperties, minProperties: $minProperties, maxProperties: $maxProperties, propertyNames: $propertyNames, dependentRequired: $dependentRequired, dependentSchemas: $dependentSchemas, dependencies: $dependencies, prefixItems: $prefixItems, items: $items, additionalItems: $additionalItems, unevaluatedItems: $unevaluatedItems, contains: $contains, minContains: $minContains, maxContains: $maxContains, minItems: $minItems, maxItems: $maxItems, uniqueItems: $uniqueItems, minimum: $minimum, maximum: $maximum, exclusiveMinimum: $exclusiveMinimum, exclusiveMaximum: $exclusiveMaximum, multipleOf: $multipleOf, minLength: $minLength, maxLength: $maxLength, pattern: $pattern, __absolute_ref__, __absolute_recursive_ref__ } = schema;
  const errors = [];
  if ($recursiveAnchor === true && recursiveAnchor === null) {
    recursiveAnchor = schema;
  }
  if ($recursiveRef === "#") {
    const refSchema = recursiveAnchor === null ? lookup[__absolute_recursive_ref__] : recursiveAnchor;
    const keywordLocation = `${schemaLocation}/$recursiveRef`;
    const result = validate(instance, recursiveAnchor === null ? schema : recursiveAnchor, draft, lookup, shortCircuit, refSchema, instanceLocation, keywordLocation, evaluated);
    if (!result.valid) {
      errors.push({
        instanceLocation,
        keyword: "$recursiveRef",
        keywordLocation,
        error: "A subschema had errors."
      }, ...result.errors);
    }
  }
  if ($ref !== void 0) {
    const uri2 = __absolute_ref__ || $ref;
    const refSchema = lookup[uri2];
    if (refSchema === void 0) {
      let message = `Unresolved $ref "${$ref}".`;
      if (__absolute_ref__ && __absolute_ref__ !== $ref) {
        message += `  Absolute URI "${__absolute_ref__}".`;
      }
      message += `
Known schemas:
- ${Object.keys(lookup).join("\n- ")}`;
      throw new Error(message);
    }
    const keywordLocation = `${schemaLocation}/$ref`;
    const result = validate(instance, refSchema, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, keywordLocation, evaluated);
    if (!result.valid) {
      errors.push({
        instanceLocation,
        keyword: "$ref",
        keywordLocation,
        error: "A subschema had errors."
      }, ...result.errors);
    }
    if (draft === "4" || draft === "7") {
      return { valid: errors.length === 0, errors };
    }
  }
  if (Array.isArray($type)) {
    let length = $type.length;
    let valid = false;
    for (let i = 0; i < length; i++) {
      if (instanceType === $type[i] || $type[i] === "integer" && instanceType === "number" && instance % 1 === 0 && instance === instance) {
        valid = true;
        break;
      }
    }
    if (!valid) {
      errors.push({
        instanceLocation,
        keyword: "type",
        keywordLocation: `${schemaLocation}/type`,
        error: `Instance type "${instanceType}" is invalid. Expected "${$type.join('", "')}".`
      });
    }
  } else if ($type === "integer") {
    if (instanceType !== "number" || instance % 1 || instance !== instance) {
      errors.push({
        instanceLocation,
        keyword: "type",
        keywordLocation: `${schemaLocation}/type`,
        error: `Instance type "${instanceType}" is invalid. Expected "${$type}".`
      });
    }
  } else if ($type !== void 0 && instanceType !== $type) {
    errors.push({
      instanceLocation,
      keyword: "type",
      keywordLocation: `${schemaLocation}/type`,
      error: `Instance type "${instanceType}" is invalid. Expected "${$type}".`
    });
  }
  if ($const !== void 0) {
    if (instanceType === "object" || instanceType === "array") {
      if (!deepCompareStrict(instance, $const)) {
        errors.push({
          instanceLocation,
          keyword: "const",
          keywordLocation: `${schemaLocation}/const`,
          error: `Instance does not match ${JSON.stringify($const)}.`
        });
      }
    } else if (instance !== $const) {
      errors.push({
        instanceLocation,
        keyword: "const",
        keywordLocation: `${schemaLocation}/const`,
        error: `Instance does not match ${JSON.stringify($const)}.`
      });
    }
  }
  if ($enum !== void 0) {
    if (instanceType === "object" || instanceType === "array") {
      if (!$enum.some((value) => deepCompareStrict(instance, value))) {
        errors.push({
          instanceLocation,
          keyword: "enum",
          keywordLocation: `${schemaLocation}/enum`,
          error: `Instance does not match any of ${JSON.stringify($enum)}.`
        });
      }
    } else if (!$enum.some((value) => instance === value)) {
      errors.push({
        instanceLocation,
        keyword: "enum",
        keywordLocation: `${schemaLocation}/enum`,
        error: `Instance does not match any of ${JSON.stringify($enum)}.`
      });
    }
  }
  if ($not !== void 0) {
    const keywordLocation = `${schemaLocation}/not`;
    const result = validate(instance, $not, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, keywordLocation);
    if (result.valid) {
      errors.push({
        instanceLocation,
        keyword: "not",
        keywordLocation,
        error: 'Instance matched "not" schema.'
      });
    }
  }
  let subEvaluateds = [];
  if ($anyOf !== void 0) {
    const keywordLocation = `${schemaLocation}/anyOf`;
    const errorsLength = errors.length;
    let anyValid = false;
    for (let i = 0; i < $anyOf.length; i++) {
      const subSchema = $anyOf[i];
      const subEvaluated = Object.create(evaluated);
      const result = validate(instance, subSchema, draft, lookup, shortCircuit, $recursiveAnchor === true ? recursiveAnchor : null, instanceLocation, `${keywordLocation}/${i}`, subEvaluated);
      errors.push(...result.errors);
      anyValid = anyValid || result.valid;
      if (result.valid) {
        subEvaluateds.push(subEvaluated);
      }
    }
    if (anyValid) {
      errors.length = errorsLength;
    } else {
      errors.splice(errorsLength, 0, {
        instanceLocation,
        keyword: "anyOf",
        keywordLocation,
        error: "Instance does not match any subschemas."
      });
    }
  }
  if ($allOf !== void 0) {
    const keywordLocation = `${schemaLocation}/allOf`;
    const errorsLength = errors.length;
    let allValid = true;
    for (let i = 0; i < $allOf.length; i++) {
      const subSchema = $allOf[i];
      const subEvaluated = Object.create(evaluated);
      const result = validate(instance, subSchema, draft, lookup, shortCircuit, $recursiveAnchor === true ? recursiveAnchor : null, instanceLocation, `${keywordLocation}/${i}`, subEvaluated);
      errors.push(...result.errors);
      allValid = allValid && result.valid;
      if (result.valid) {
        subEvaluateds.push(subEvaluated);
      }
    }
    if (allValid) {
      errors.length = errorsLength;
    } else {
      errors.splice(errorsLength, 0, {
        instanceLocation,
        keyword: "allOf",
        keywordLocation,
        error: `Instance does not match every subschema.`
      });
    }
  }
  if ($oneOf !== void 0) {
    const keywordLocation = `${schemaLocation}/oneOf`;
    const errorsLength = errors.length;
    const matches = $oneOf.filter((subSchema, i) => {
      const subEvaluated = Object.create(evaluated);
      const result = validate(instance, subSchema, draft, lookup, shortCircuit, $recursiveAnchor === true ? recursiveAnchor : null, instanceLocation, `${keywordLocation}/${i}`, subEvaluated);
      errors.push(...result.errors);
      if (result.valid) {
        subEvaluateds.push(subEvaluated);
      }
      return result.valid;
    }).length;
    if (matches === 1) {
      errors.length = errorsLength;
    } else {
      errors.splice(errorsLength, 0, {
        instanceLocation,
        keyword: "oneOf",
        keywordLocation,
        error: `Instance does not match exactly one subschema (${matches} matches).`
      });
    }
  }
  if (instanceType === "object" || instanceType === "array") {
    Object.assign(evaluated, ...subEvaluateds);
  }
  if ($if !== void 0) {
    const keywordLocation = `${schemaLocation}/if`;
    const conditionResult = validate(instance, $if, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, keywordLocation, evaluated).valid;
    if (conditionResult) {
      if ($then !== void 0) {
        const thenResult = validate(instance, $then, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, `${schemaLocation}/then`, evaluated);
        if (!thenResult.valid) {
          errors.push({
            instanceLocation,
            keyword: "if",
            keywordLocation,
            error: `Instance does not match "then" schema.`
          }, ...thenResult.errors);
        }
      }
    } else if ($else !== void 0) {
      const elseResult = validate(instance, $else, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, `${schemaLocation}/else`, evaluated);
      if (!elseResult.valid) {
        errors.push({
          instanceLocation,
          keyword: "if",
          keywordLocation,
          error: `Instance does not match "else" schema.`
        }, ...elseResult.errors);
      }
    }
  }
  if (instanceType === "object") {
    if ($required !== void 0) {
      for (const key of $required) {
        if (!(key in instance)) {
          errors.push({
            instanceLocation,
            keyword: "required",
            keywordLocation: `${schemaLocation}/required`,
            error: `Instance does not have required property "${key}".`
          });
        }
      }
    }
    const keys = Object.keys(instance);
    if ($minProperties !== void 0 && keys.length < $minProperties) {
      errors.push({
        instanceLocation,
        keyword: "minProperties",
        keywordLocation: `${schemaLocation}/minProperties`,
        error: `Instance does not have at least ${$minProperties} properties.`
      });
    }
    if ($maxProperties !== void 0 && keys.length > $maxProperties) {
      errors.push({
        instanceLocation,
        keyword: "maxProperties",
        keywordLocation: `${schemaLocation}/maxProperties`,
        error: `Instance does not have at least ${$maxProperties} properties.`
      });
    }
    if ($propertyNames !== void 0) {
      const keywordLocation = `${schemaLocation}/propertyNames`;
      for (const key in instance) {
        const subInstancePointer = `${instanceLocation}/${encodePointer(key)}`;
        const result = validate(key, $propertyNames, draft, lookup, shortCircuit, recursiveAnchor, subInstancePointer, keywordLocation);
        if (!result.valid) {
          errors.push({
            instanceLocation,
            keyword: "propertyNames",
            keywordLocation,
            error: `Property name "${key}" does not match schema.`
          }, ...result.errors);
        }
      }
    }
    if ($dependentRequired !== void 0) {
      const keywordLocation = `${schemaLocation}/dependantRequired`;
      for (const key in $dependentRequired) {
        if (key in instance) {
          const required = $dependentRequired[key];
          for (const dependantKey of required) {
            if (!(dependantKey in instance)) {
              errors.push({
                instanceLocation,
                keyword: "dependentRequired",
                keywordLocation,
                error: `Instance has "${key}" but does not have "${dependantKey}".`
              });
            }
          }
        }
      }
    }
    if ($dependentSchemas !== void 0) {
      for (const key in $dependentSchemas) {
        const keywordLocation = `${schemaLocation}/dependentSchemas`;
        if (key in instance) {
          const result = validate(instance, $dependentSchemas[key], draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, `${keywordLocation}/${encodePointer(key)}`, evaluated);
          if (!result.valid) {
            errors.push({
              instanceLocation,
              keyword: "dependentSchemas",
              keywordLocation,
              error: `Instance has "${key}" but does not match dependant schema.`
            }, ...result.errors);
          }
        }
      }
    }
    if ($dependencies !== void 0) {
      const keywordLocation = `${schemaLocation}/dependencies`;
      for (const key in $dependencies) {
        if (key in instance) {
          const propsOrSchema = $dependencies[key];
          if (Array.isArray(propsOrSchema)) {
            for (const dependantKey of propsOrSchema) {
              if (!(dependantKey in instance)) {
                errors.push({
                  instanceLocation,
                  keyword: "dependencies",
                  keywordLocation,
                  error: `Instance has "${key}" but does not have "${dependantKey}".`
                });
              }
            }
          } else {
            const result = validate(instance, propsOrSchema, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, `${keywordLocation}/${encodePointer(key)}`);
            if (!result.valid) {
              errors.push({
                instanceLocation,
                keyword: "dependencies",
                keywordLocation,
                error: `Instance has "${key}" but does not match dependant schema.`
              }, ...result.errors);
            }
          }
        }
      }
    }
    const thisEvaluated = /* @__PURE__ */ Object.create(null);
    let stop = false;
    if ($properties !== void 0) {
      const keywordLocation = `${schemaLocation}/properties`;
      for (const key in $properties) {
        if (!(key in instance)) {
          continue;
        }
        const subInstancePointer = `${instanceLocation}/${encodePointer(key)}`;
        const result = validate(instance[key], $properties[key], draft, lookup, shortCircuit, recursiveAnchor, subInstancePointer, `${keywordLocation}/${encodePointer(key)}`);
        if (result.valid) {
          evaluated[key] = thisEvaluated[key] = true;
        } else {
          stop = shortCircuit;
          errors.push({
            instanceLocation,
            keyword: "properties",
            keywordLocation,
            error: `Property "${key}" does not match schema.`
          }, ...result.errors);
          if (stop)
            break;
        }
      }
    }
    if (!stop && $patternProperties !== void 0) {
      const keywordLocation = `${schemaLocation}/patternProperties`;
      for (const pattern in $patternProperties) {
        const regex2 = new RegExp(pattern, "u");
        const subSchema = $patternProperties[pattern];
        for (const key in instance) {
          if (!regex2.test(key)) {
            continue;
          }
          const subInstancePointer = `${instanceLocation}/${encodePointer(key)}`;
          const result = validate(instance[key], subSchema, draft, lookup, shortCircuit, recursiveAnchor, subInstancePointer, `${keywordLocation}/${encodePointer(pattern)}`);
          if (result.valid) {
            evaluated[key] = thisEvaluated[key] = true;
          } else {
            stop = shortCircuit;
            errors.push({
              instanceLocation,
              keyword: "patternProperties",
              keywordLocation,
              error: `Property "${key}" matches pattern "${pattern}" but does not match associated schema.`
            }, ...result.errors);
          }
        }
      }
    }
    if (!stop && $additionalProperties !== void 0) {
      const keywordLocation = `${schemaLocation}/additionalProperties`;
      for (const key in instance) {
        if (thisEvaluated[key]) {
          continue;
        }
        const subInstancePointer = `${instanceLocation}/${encodePointer(key)}`;
        const result = validate(instance[key], $additionalProperties, draft, lookup, shortCircuit, recursiveAnchor, subInstancePointer, keywordLocation);
        if (result.valid) {
          evaluated[key] = true;
        } else {
          stop = shortCircuit;
          errors.push({
            instanceLocation,
            keyword: "additionalProperties",
            keywordLocation,
            error: `Property "${key}" does not match additional properties schema.`
          }, ...result.errors);
        }
      }
    } else if (!stop && $unevaluatedProperties !== void 0) {
      const keywordLocation = `${schemaLocation}/unevaluatedProperties`;
      for (const key in instance) {
        if (!evaluated[key]) {
          const subInstancePointer = `${instanceLocation}/${encodePointer(key)}`;
          const result = validate(instance[key], $unevaluatedProperties, draft, lookup, shortCircuit, recursiveAnchor, subInstancePointer, keywordLocation);
          if (result.valid) {
            evaluated[key] = true;
          } else {
            errors.push({
              instanceLocation,
              keyword: "unevaluatedProperties",
              keywordLocation,
              error: `Property "${key}" does not match unevaluated properties schema.`
            }, ...result.errors);
          }
        }
      }
    }
  } else if (instanceType === "array") {
    if ($maxItems !== void 0 && instance.length > $maxItems) {
      errors.push({
        instanceLocation,
        keyword: "maxItems",
        keywordLocation: `${schemaLocation}/maxItems`,
        error: `Array has too many items (${instance.length} > ${$maxItems}).`
      });
    }
    if ($minItems !== void 0 && instance.length < $minItems) {
      errors.push({
        instanceLocation,
        keyword: "minItems",
        keywordLocation: `${schemaLocation}/minItems`,
        error: `Array has too few items (${instance.length} < ${$minItems}).`
      });
    }
    const length = instance.length;
    let i = 0;
    let stop = false;
    if ($prefixItems !== void 0) {
      const keywordLocation = `${schemaLocation}/prefixItems`;
      const length2 = Math.min($prefixItems.length, length);
      for (; i < length2; i++) {
        const result = validate(instance[i], $prefixItems[i], draft, lookup, shortCircuit, recursiveAnchor, `${instanceLocation}/${i}`, `${keywordLocation}/${i}`);
        evaluated[i] = true;
        if (!result.valid) {
          stop = shortCircuit;
          errors.push({
            instanceLocation,
            keyword: "prefixItems",
            keywordLocation,
            error: `Items did not match schema.`
          }, ...result.errors);
          if (stop)
            break;
        }
      }
    }
    if ($items !== void 0) {
      const keywordLocation = `${schemaLocation}/items`;
      if (Array.isArray($items)) {
        const length2 = Math.min($items.length, length);
        for (; i < length2; i++) {
          const result = validate(instance[i], $items[i], draft, lookup, shortCircuit, recursiveAnchor, `${instanceLocation}/${i}`, `${keywordLocation}/${i}`);
          evaluated[i] = true;
          if (!result.valid) {
            stop = shortCircuit;
            errors.push({
              instanceLocation,
              keyword: "items",
              keywordLocation,
              error: `Items did not match schema.`
            }, ...result.errors);
            if (stop)
              break;
          }
        }
      } else {
        for (; i < length; i++) {
          const result = validate(instance[i], $items, draft, lookup, shortCircuit, recursiveAnchor, `${instanceLocation}/${i}`, keywordLocation);
          evaluated[i] = true;
          if (!result.valid) {
            stop = shortCircuit;
            errors.push({
              instanceLocation,
              keyword: "items",
              keywordLocation,
              error: `Items did not match schema.`
            }, ...result.errors);
            if (stop)
              break;
          }
        }
      }
      if (!stop && $additionalItems !== void 0) {
        const keywordLocation2 = `${schemaLocation}/additionalItems`;
        for (; i < length; i++) {
          const result = validate(instance[i], $additionalItems, draft, lookup, shortCircuit, recursiveAnchor, `${instanceLocation}/${i}`, keywordLocation2);
          evaluated[i] = true;
          if (!result.valid) {
            stop = shortCircuit;
            errors.push({
              instanceLocation,
              keyword: "additionalItems",
              keywordLocation: keywordLocation2,
              error: `Items did not match additional items schema.`
            }, ...result.errors);
          }
        }
      }
    }
    if ($contains !== void 0) {
      if (length === 0 && $minContains === void 0) {
        errors.push({
          instanceLocation,
          keyword: "contains",
          keywordLocation: `${schemaLocation}/contains`,
          error: `Array is empty. It must contain at least one item matching the schema.`
        });
      } else if ($minContains !== void 0 && length < $minContains) {
        errors.push({
          instanceLocation,
          keyword: "minContains",
          keywordLocation: `${schemaLocation}/minContains`,
          error: `Array has less items (${length}) than minContains (${$minContains}).`
        });
      } else {
        const keywordLocation = `${schemaLocation}/contains`;
        const errorsLength = errors.length;
        let contained = 0;
        for (let j = 0; j < length; j++) {
          const result = validate(instance[j], $contains, draft, lookup, shortCircuit, recursiveAnchor, `${instanceLocation}/${j}`, keywordLocation);
          if (result.valid) {
            evaluated[j] = true;
            contained++;
          } else {
            errors.push(...result.errors);
          }
        }
        if (contained >= ($minContains || 0)) {
          errors.length = errorsLength;
        }
        if ($minContains === void 0 && $maxContains === void 0 && contained === 0) {
          errors.splice(errorsLength, 0, {
            instanceLocation,
            keyword: "contains",
            keywordLocation,
            error: `Array does not contain item matching schema.`
          });
        } else if ($minContains !== void 0 && contained < $minContains) {
          errors.push({
            instanceLocation,
            keyword: "minContains",
            keywordLocation: `${schemaLocation}/minContains`,
            error: `Array must contain at least ${$minContains} items matching schema. Only ${contained} items were found.`
          });
        } else if ($maxContains !== void 0 && contained > $maxContains) {
          errors.push({
            instanceLocation,
            keyword: "maxContains",
            keywordLocation: `${schemaLocation}/maxContains`,
            error: `Array may contain at most ${$maxContains} items matching schema. ${contained} items were found.`
          });
        }
      }
    }
    if (!stop && $unevaluatedItems !== void 0) {
      const keywordLocation = `${schemaLocation}/unevaluatedItems`;
      for (i; i < length; i++) {
        if (evaluated[i]) {
          continue;
        }
        const result = validate(instance[i], $unevaluatedItems, draft, lookup, shortCircuit, recursiveAnchor, `${instanceLocation}/${i}`, keywordLocation);
        evaluated[i] = true;
        if (!result.valid) {
          errors.push({
            instanceLocation,
            keyword: "unevaluatedItems",
            keywordLocation,
            error: `Items did not match unevaluated items schema.`
          }, ...result.errors);
        }
      }
    }
    if ($uniqueItems) {
      for (let j = 0; j < length; j++) {
        const a = instance[j];
        const ao = typeof a === "object" && a !== null;
        for (let k = 0; k < length; k++) {
          if (j === k) {
            continue;
          }
          const b = instance[k];
          const bo = typeof b === "object" && b !== null;
          if (a === b || ao && bo && deepCompareStrict(a, b)) {
            errors.push({
              instanceLocation,
              keyword: "uniqueItems",
              keywordLocation: `${schemaLocation}/uniqueItems`,
              error: `Duplicate items at indexes ${j} and ${k}.`
            });
            j = Number.MAX_SAFE_INTEGER;
            k = Number.MAX_SAFE_INTEGER;
          }
        }
      }
    }
  } else if (instanceType === "number") {
    if (draft === "4") {
      if ($minimum !== void 0 && ($exclusiveMinimum === true && instance <= $minimum || instance < $minimum)) {
        errors.push({
          instanceLocation,
          keyword: "minimum",
          keywordLocation: `${schemaLocation}/minimum`,
          error: `${instance} is less than ${$exclusiveMinimum ? "or equal to " : ""} ${$minimum}.`
        });
      }
      if ($maximum !== void 0 && ($exclusiveMaximum === true && instance >= $maximum || instance > $maximum)) {
        errors.push({
          instanceLocation,
          keyword: "maximum",
          keywordLocation: `${schemaLocation}/maximum`,
          error: `${instance} is greater than ${$exclusiveMaximum ? "or equal to " : ""} ${$maximum}.`
        });
      }
    } else {
      if ($minimum !== void 0 && instance < $minimum) {
        errors.push({
          instanceLocation,
          keyword: "minimum",
          keywordLocation: `${schemaLocation}/minimum`,
          error: `${instance} is less than ${$minimum}.`
        });
      }
      if ($maximum !== void 0 && instance > $maximum) {
        errors.push({
          instanceLocation,
          keyword: "maximum",
          keywordLocation: `${schemaLocation}/maximum`,
          error: `${instance} is greater than ${$maximum}.`
        });
      }
      if ($exclusiveMinimum !== void 0 && instance <= $exclusiveMinimum) {
        errors.push({
          instanceLocation,
          keyword: "exclusiveMinimum",
          keywordLocation: `${schemaLocation}/exclusiveMinimum`,
          error: `${instance} is less than ${$exclusiveMinimum}.`
        });
      }
      if ($exclusiveMaximum !== void 0 && instance >= $exclusiveMaximum) {
        errors.push({
          instanceLocation,
          keyword: "exclusiveMaximum",
          keywordLocation: `${schemaLocation}/exclusiveMaximum`,
          error: `${instance} is greater than or equal to ${$exclusiveMaximum}.`
        });
      }
    }
    if ($multipleOf !== void 0) {
      const remainder = instance % $multipleOf;
      if (Math.abs(0 - remainder) >= 11920929e-14 && Math.abs($multipleOf - remainder) >= 11920929e-14) {
        errors.push({
          instanceLocation,
          keyword: "multipleOf",
          keywordLocation: `${schemaLocation}/multipleOf`,
          error: `${instance} is not a multiple of ${$multipleOf}.`
        });
      }
    }
  } else if (instanceType === "string") {
    const length = $minLength === void 0 && $maxLength === void 0 ? 0 : ucs2length(instance);
    if ($minLength !== void 0 && length < $minLength) {
      errors.push({
        instanceLocation,
        keyword: "minLength",
        keywordLocation: `${schemaLocation}/minLength`,
        error: `String is too short (${length} < ${$minLength}).`
      });
    }
    if ($maxLength !== void 0 && length > $maxLength) {
      errors.push({
        instanceLocation,
        keyword: "maxLength",
        keywordLocation: `${schemaLocation}/maxLength`,
        error: `String is too long (${length} > ${$maxLength}).`
      });
    }
    if ($pattern !== void 0 && !new RegExp($pattern, "u").test(instance)) {
      errors.push({
        instanceLocation,
        keyword: "pattern",
        keywordLocation: `${schemaLocation}/pattern`,
        error: `String does not match pattern.`
      });
    }
    if ($format !== void 0 && fastFormat[$format] && !fastFormat[$format](instance)) {
      errors.push({
        instanceLocation,
        keyword: "format",
        keywordLocation: `${schemaLocation}/format`,
        error: `String does not match format "${$format}".`
      });
    }
  }
  return { valid: errors.length === 0, errors };
}
__name(validate, "validate");

// node_modules/@cfworker/json-schema/dist/validator.js
var Validator = class {
  static {
    __name(this, "Validator");
  }
  constructor(schema, draft = "2019-09", shortCircuit = true) {
    this.schema = schema;
    this.draft = draft;
    this.shortCircuit = shortCircuit;
    this.lookup = dereference(schema);
  }
  validate(instance) {
    return validate(instance, this.schema, this.draft, this.lookup, this.shortCircuit);
  }
  addSchema(schema, id) {
    if (id) {
      schema = { ...schema, $id: id };
    }
    dereference(schema, this.lookup);
  }
};

// src/index.ts
var schemaCache = /* @__PURE__ */ new Map();
function generateEngineIdentity(request, env) {
  const cf = request.cf || {};
  return {
    gateway_version: env.GATEWAY_VERSION,
    cf_metadata: {
      colo: cf.colo || "unknown",
      country: cf.country || "unknown",
      asn: cf.asn || "unknown"
    },
    config: {
      bindings: {
        kv_namespaces: ["POLICY_KV"],
        d1_databases: ["EPISODES_DB"],
        r2_buckets: ["ARTIFACTS"]
      },
      env: "production"
      // Could be determined from request headers or env vars
    },
    timestamp: (/* @__PURE__ */ new Date()).toISOString()
  };
}
__name(generateEngineIdentity, "generateEngineIdentity");
async function loadPolicy(policyRef, env) {
  const versionKey = `policy:active:${policyRef}`;
  const version = await env.POLICY_KV.get(versionKey);
  if (!version) {
    return null;
  }
  const policyKey = `policy:${policyRef}:${version}`;
  const policyJson = await env.POLICY_KV.get(policyKey);
  if (!policyJson) {
    return null;
  }
  return JSON.parse(policyJson);
}
__name(loadPolicy, "loadPolicy");
function checkPolicy(toolId, args, policy) {
  if (policy.default_decision === "deny") {
    if (policy.tool_allowlist && policy.tool_allowlist.includes(toolId)) {
      if (toolId === "http.fetch" && args.url) {
        try {
          const url = new URL(args.url);
          const hostname = url.hostname;
          if (policy.http_fetch_hostname_allowlist && policy.http_fetch_hostname_allowlist.length > 0 && !policy.http_fetch_hostname_allowlist.includes(hostname)) {
            return {
              decision: "deny",
              reason: `Hostname ${hostname} not in allowlist`,
              rule_id: "http_fetch_hostname_check"
            };
          }
        } catch (e) {
          return {
            decision: "deny",
            reason: `Invalid URL: ${e}`,
            rule_id: "http_fetch_url_validation"
          };
        }
      }
      return {
        decision: "allow",
        reason: `Tool ${toolId} is in allowlist`,
        rule_id: "tool_allowlist_match"
      };
    }
    return {
      decision: "deny",
      reason: `Tool ${toolId} not in allowlist (default deny)`,
      rule_id: "default_deny"
    };
  }
  return {
    decision: "allow",
    reason: "Default allow policy",
    rule_id: "default_allow"
  };
}
__name(checkPolicy, "checkPolicy");
async function executeTool(toolId, args, env) {
  if (toolId === "kv.get") {
    const key = args.key;
    if (!key || typeof key !== "string") {
      return {
        exit_code: 1,
        stdout: "",
        stderr: "kv.get requires key (string)"
      };
    }
    try {
      const value = await env.POLICY_KV.get(key);
      return {
        exit_code: 0,
        stdout: "",
        stderr: "",
        data: value
        // null if key not found, string if found
      };
    } catch (error) {
      return {
        exit_code: 1,
        stdout: "",
        stderr: `kv.get error: ${error.message || "Unknown error"}`,
        data: null
      };
    }
  }
  if (toolId === "http.fetch") {
    const url = args.url;
    if (!url || typeof url !== "string") {
      return {
        exit_code: 1,
        stdout: "",
        stderr: "http.fetch requires url (string)"
      };
    }
    const method = args.method || "GET";
    if (method !== "GET") {
      return {
        exit_code: 1,
        stdout: "",
        stderr: "http.fetch v0 supports GET only"
      };
    }
    try {
      const response = await fetch(url, {
        method: "GET",
        headers: args.headers || {}
      });
      const text = await response.text();
      const headers = {};
      const headerNames = ["content-type", "content-length", "cache-control"];
      headerNames.forEach((name) => {
        const value = response.headers.get(name);
        if (value) {
          headers[name] = value;
        }
      });
      return {
        exit_code: response.ok ? 0 : 1,
        stdout: text,
        stderr: response.ok ? "" : `HTTP ${response.status}`,
        data: text,
        status: response.status,
        headers
      };
    } catch (error) {
      return {
        exit_code: 1,
        stdout: "",
        stderr: `Fetch error: ${error.message}`
      };
    }
  }
  return {
    exit_code: 1,
    stdout: "",
    stderr: `Unknown tool: ${toolId}`
  };
}
__name(executeTool, "executeTool");
async function sha256(text) {
  const encoder = new TextEncoder();
  const data = encoder.encode(text);
  const hashBuffer = await crypto.subtle.digest("SHA-256", data);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  return hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
}
__name(sha256, "sha256");
async function loadSchema(schemaRef, env) {
  const [schemaId, version] = schemaRef.split("@");
  if (!schemaId || !version) {
    return null;
  }
  const schemaKey = `schema:${schemaId}:${version}`;
  const schemaJson = await env.POLICY_KV.get(schemaKey);
  if (!schemaJson) {
    return null;
  }
  return JSON.parse(schemaJson);
}
__name(loadSchema, "loadSchema");
function prepareSchemaValidator(schemaJson, schemaHash) {
  const cached = schemaCache.get(schemaHash);
  if (cached) {
    return cached;
  }
  const validator = new Validator(schemaJson);
  const cachedValidator = {
    validator,
    timestamp: Date.now()
  };
  if (schemaCache.size > 100) {
    const entries = Array.from(schemaCache.entries());
    entries.sort((a, b) => a[1].timestamp - b[1].timestamp);
    for (let i = 0; i < 50; i++) {
      schemaCache.delete(entries[i][0]);
    }
  }
  schemaCache.set(schemaHash, cachedValidator);
  return cachedValidator;
}
__name(prepareSchemaValidator, "prepareSchemaValidator");
async function handleSchemaPut(request, env) {
  try {
    const authHeader = request.headers.get("Authorization");
    if (!authHeader || !authHeader.startsWith("Bearer ")) {
      return new Response(
        JSON.stringify({ ok: false, error: "Missing or invalid Authorization header" }),
        { status: 401, headers: { "Content-Type": "application/json" } }
      );
    }
    const token = authHeader.substring(7);
    const isAdmin = env.ADMIN_AUTH_TOKEN && token === env.ADMIN_AUTH_TOKEN;
    if (!isAdmin && token !== env.GATEWAY_AUTH_TOKEN) {
      return new Response(
        JSON.stringify({ ok: false, error: "Invalid auth token" }),
        { status: 401, headers: { "Content-Type": "application/json" } }
      );
    }
    const body = await request.json();
    if (!body.schema_id || typeof body.schema_id !== "string") {
      return new Response(
        JSON.stringify({ ok: false, error: "schema_id required (string)" }),
        { status: 400, headers: { "Content-Type": "application/json" } }
      );
    }
    if (!/^[a-zA-Z0-9._-]+$/.test(body.schema_id)) {
      return new Response(
        JSON.stringify({ ok: false, error: "Invalid schema_id format" }),
        { status: 400, headers: { "Content-Type": "application/json" } }
      );
    }
    if (!body.version || typeof body.version !== "string") {
      return new Response(
        JSON.stringify({ ok: false, error: "version required (string)" }),
        { status: 400, headers: { "Content-Type": "application/json" } }
      );
    }
    if (!/^[a-zA-Z0-9._-]+$/.test(body.version)) {
      return new Response(
        JSON.stringify({ ok: false, error: "Invalid version format" }),
        { status: 400, headers: { "Content-Type": "application/json" } }
      );
    }
    if (body.schema_id.length > 128 || body.version.length > 64) {
      return new Response(
        JSON.stringify({ ok: false, error: "schema_id or version too long" }),
        { status: 400, headers: { "Content-Type": "application/json" } }
      );
    }
    if (!body.schema_json || typeof body.schema_json !== "object") {
      return new Response(
        JSON.stringify({ ok: false, error: "schema_json required (object)" }),
        { status: 400, headers: { "Content-Type": "application/json" } }
      );
    }
    const schemaJsonStr = JSON.stringify(body.schema_json);
    const schemaSize = new TextEncoder().encode(schemaJsonStr).length;
    if (schemaSize > 64 * 1024) {
      return new Response(
        JSON.stringify({ ok: false, error: "schema_json too large (max 64KB)" }),
        { status: 400, headers: { "Content-Type": "application/json" } }
      );
    }
    const schemaHash = await sha256(schemaJsonStr);
    const schemaKey = `schema:${body.schema_id}:${body.version}`;
    await env.POLICY_KV.put(schemaKey, schemaJsonStr);
    const metaKey = `schema:meta:${body.schema_id}:${body.version}`;
    const meta = {
      ts: Date.now(),
      sha256: schemaHash,
      size: schemaSize
    };
    await env.POLICY_KV.put(metaKey, JSON.stringify(meta));
    const activeKey = `schema:active:${body.schema_id}`;
    await env.POLICY_KV.put(activeKey, body.version);
    return new Response(
      JSON.stringify({
        ok: true,
        schema_ref: `${body.schema_id}@${body.version}`,
        schema_hash: schemaHash
      }),
      { headers: { "Content-Type": "application/json" } }
    );
  } catch (error) {
    return new Response(
      JSON.stringify({ ok: false, error: error.message }),
      { status: 500, headers: { "Content-Type": "application/json" } }
    );
  }
}
__name(handleSchemaPut, "handleSchemaPut");
async function handleSchemaGet(request, env) {
  try {
    const authHeader = request.headers.get("Authorization");
    if (!authHeader || !authHeader.startsWith("Bearer ")) {
      return new Response(
        JSON.stringify({ ok: false, error: "Missing or invalid Authorization header" }),
        { status: 401, headers: { "Content-Type": "application/json" } }
      );
    }
    const token = authHeader.substring(7);
    if (token !== env.GATEWAY_AUTH_TOKEN && token !== env.ADMIN_AUTH_TOKEN) {
      return new Response(
        JSON.stringify({ ok: false, error: "Invalid auth token" }),
        { status: 401, headers: { "Content-Type": "application/json" } }
      );
    }
    const url = new URL(request.url);
    const schemaId = url.searchParams.get("schema_id");
    const version = url.searchParams.get("version");
    if (!schemaId || !version) {
      return new Response(
        JSON.stringify({ ok: false, error: "Missing schema_id or version parameter" }),
        { status: 400, headers: { "Content-Type": "application/json" } }
      );
    }
    const schemaKey = `schema:${schemaId}:${version}`;
    const schemaJson = await env.POLICY_KV.get(schemaKey);
    if (!schemaJson) {
      return new Response(
        JSON.stringify({ ok: false, error: "Schema not found" }),
        { status: 404, headers: { "Content-Type": "application/json" } }
      );
    }
    return new Response(schemaJson, {
      headers: { "Content-Type": "application/json" }
    });
  } catch (error) {
    return new Response(
      JSON.stringify({ ok: false, error: error.message }),
      { status: 500, headers: { "Content-Type": "application/json" } }
    );
  }
}
__name(handleSchemaGet, "handleSchemaGet");
async function writePayloadValidateEpisode(requestId, runId, stepId, engineRef, variant, dsPayloadRef, dsPayloadHash, cacheHit, compileMs, validateMs, valid, errors, evidenceRefs, payload, env) {
  const ts = Date.now();
  const type = "payload_validate";
  const episodePayload = {
    ...payload,
    variant,
    ds_payload_ref: dsPayloadRef,
    ds_payload_hash: dsPayloadHash,
    cache_hit: cacheHit,
    compile_ms: compileMs,
    validate_ms: validateMs,
    valid,
    errors
  };
  await env.EPISODES_DB.prepare(`
    INSERT INTO episodes (
      id, ts, type, run_id, step_id, policy_ref, policy_version,
      engine_ref, decision, reason, evidence_refs_json, payload_json
    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
  `).bind(
    requestId,
    ts,
    type,
    runId,
    stepId,
    "schema_payload_experiment",
    "v1",
    engineRef,
    valid ? "allow" : "deny",
    valid ? "Payload valid" : `Payload invalid: ${errors.join("; ")}`,
    JSON.stringify(evidenceRefs),
    JSON.stringify(episodePayload)
  ).run();
}
__name(writePayloadValidateEpisode, "writePayloadValidateEpisode");
async function handlePayloadValidate(request, env) {
  const startTime = Date.now();
  let requestId = `payload_validate_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  try {
    const authHeader = request.headers.get("Authorization");
    if (!authHeader || !authHeader.startsWith("Bearer ")) {
      return new Response(
        JSON.stringify({ ok: false, error: "Missing or invalid Authorization header" }),
        { status: 401, headers: { "Content-Type": "application/json" } }
      );
    }
    const token = authHeader.substring(7);
    const isAdmin = env.ADMIN_AUTH_TOKEN && token === env.ADMIN_AUTH_TOKEN;
    const isRegular = token === env.GATEWAY_AUTH_TOKEN;
    if (!isAdmin && !isRegular) {
      return new Response(
        JSON.stringify({ ok: false, error: "Invalid auth token" }),
        { status: 401, headers: { "Content-Type": "application/json" } }
      );
    }
    const body = await request.json();
    const engineIdentity = generateEngineIdentity(request, env);
    const engineRef = `${env.GATEWAY_VERSION}@${request.cf?.colo || "unknown"}`;
    const evidenceRefs = [];
    const runId = `run_${requestId}`;
    const stepId = `step_${requestId}`;
    const requestKey = `payload_validate/${requestId}/request.json`;
    await env.ARTIFACTS.put(requestKey, JSON.stringify(body, null, 2));
    evidenceRefs.push(requestKey);
    const identityKey = `payload_validate/${requestId}/engine_identity.json`;
    await env.ARTIFACTS.put(identityKey, JSON.stringify(engineIdentity, null, 2));
    evidenceRefs.push(identityKey);
    let schemaJson = null;
    let schemaHash = "";
    let dsPayloadRef = void 0;
    let cacheHit = false;
    let compileMs = 0;
    let validateMs = 0;
    let valid = false;
    let errors = [];
    if (body.variant === "v0") {
      schemaJson = {
        "$schema": "https://json-schema.org/draft/2020-12/schema",
        "type": "object",
        "required": ["kind", "data"],
        "properties": {
          "kind": { "type": "string" },
          "data": { "type": "object", "additionalProperties": true },
          "meta": { "type": "object", "additionalProperties": true }
        }
      };
      const schemaJsonStr = JSON.stringify(schemaJson);
      schemaHash = await sha256(schemaJsonStr);
      dsPayloadRef = "payload@v1";
    } else if (body.variant === "v1") {
      if (!body.schema_ref) {
        return new Response(
          JSON.stringify({ ok: false, error: "schema_ref required for variant v1" }),
          { status: 400, headers: { "Content-Type": "application/json" } }
        );
      }
      schemaJson = await loadSchema(body.schema_ref, env);
      if (!schemaJson) {
        return new Response(
          JSON.stringify({ ok: false, error: `Schema ${body.schema_ref} not found` }),
          { status: 404, headers: { "Content-Type": "application/json" } }
        );
      }
      const schemaJsonStr = JSON.stringify(schemaJson);
      schemaHash = await sha256(schemaJsonStr);
      dsPayloadRef = body.schema_ref;
    } else if (body.variant === "v2") {
      const allowInline = env.ALLOW_INLINE_SCHEMA === "true" || isAdmin;
      if (!allowInline) {
        const policyCheck = {
          decision: "deny",
          reason: "V2 inline schema not allowed (deny-by-default)",
          rule_id: "v2_inline_schema_deny"
        };
        const denyKey = `payload_validate/${requestId}/policy_deny.json`;
        await env.ARTIFACTS.put(denyKey, JSON.stringify(policyCheck, null, 2));
        evidenceRefs.push(denyKey);
        await writePayloadValidateEpisode(
          requestId,
          runId,
          stepId,
          engineRef,
          "v2",
          void 0,
          void 0,
          false,
          0,
          0,
          false,
          [policyCheck.reason],
          evidenceRefs,
          { request: body, policy_check: policyCheck },
          env
        );
        return new Response(
          JSON.stringify({
            ok: true,
            valid: false,
            errors: [policyCheck.reason],
            policy_check: policyCheck,
            cache_hit: false,
            compile_ms: 0,
            validate_ms: 0,
            engine_ref: engineRef,
            evidence_refs: evidenceRefs
          }),
          { status: 403, headers: { "Content-Type": "application/json" } }
        );
      }
      if (!body.schema_inline) {
        return new Response(
          JSON.stringify({ ok: false, error: "schema_inline required for variant v2" }),
          { status: 400, headers: { "Content-Type": "application/json" } }
        );
      }
      schemaJson = body.schema_inline;
      const schemaJsonStr = JSON.stringify(schemaJson);
      schemaHash = await sha256(schemaJsonStr);
      dsPayloadRef = "inline@v2";
    } else {
      return new Response(
        JSON.stringify({ ok: false, error: "Invalid variant (must be v0, v1, or v2)" }),
        { status: 400, headers: { "Content-Type": "application/json" } }
      );
    }
    const payloadJsonStr = JSON.stringify(body.payload);
    const payloadHash = await sha256(payloadJsonStr);
    const compileStart = Date.now();
    const cached = schemaCache.get(schemaHash);
    let cachedValidator;
    if (cached) {
      cacheHit = true;
      cachedValidator = cached;
      compileMs = 0;
    } else {
      cacheHit = false;
      cachedValidator = prepareSchemaValidator(schemaJson, schemaHash);
      compileMs = Date.now() - compileStart;
    }
    const validateStart = Date.now();
    const validationResult = cachedValidator.validator.validate(body.payload);
    validateMs = Date.now() - validateStart;
    valid = validationResult.valid;
    if (!valid && validationResult.errors) {
      errors = validationResult.errors.map((e) => {
        const path = e.instanceLocation || "/";
        const message = e.error || "Validation error";
        return `${path}: ${message}`;
      });
    }
    const resultKey = `payload_validate/${requestId}/validate_result.json`;
    const validateResultData = {
      valid,
      errors,
      ds_payload_ref: dsPayloadRef,
      ds_payload_hash: payloadHash,
      cache_hit: cacheHit,
      compile_ms: compileMs,
      validate_ms: validateMs
    };
    await env.ARTIFACTS.put(resultKey, JSON.stringify(validateResultData, null, 2));
    evidenceRefs.push(resultKey);
    const responseKey = `payload_validate/${requestId}/response.json`;
    const response = {
      ok: true,
      valid,
      errors,
      // Add policy_check for successful validations (allow)
      policy_check: valid ? {
        decision: "allow",
        reason: "Payload valid",
        rule_id: "payload_validation_pass"
      } : void 0,
      ds_payload_ref: dsPayloadRef,
      ds_payload_hash: payloadHash,
      cache_hit: cacheHit,
      compile_ms: compileMs,
      validate_ms: validateMs,
      engine_ref: engineRef,
      evidence_refs: evidenceRefs
    };
    await env.ARTIFACTS.put(responseKey, JSON.stringify(response, null, 2));
    evidenceRefs.push(responseKey);
    await writePayloadValidateEpisode(
      requestId,
      runId,
      stepId,
      engineRef,
      body.variant,
      dsPayloadRef,
      payloadHash,
      cacheHit,
      compileMs,
      validateMs,
      valid,
      errors,
      evidenceRefs,
      { request: body, validate_result: validateResultData },
      env
    );
    return new Response(
      JSON.stringify(response, null, 2),
      { headers: { "Content-Type": "application/json" } }
    );
  } catch (error) {
    return new Response(
      JSON.stringify({ ok: false, error: error.message }),
      { status: 500, headers: { "Content-Type": "application/json" } }
    );
  }
}
__name(handlePayloadValidate, "handlePayloadValidate");
async function writeEpisode(requestId, runId, stepId, policyRef, policyVersion, engineRef, decision, reason, evidenceRefs, payload, env) {
  const ts = Date.now();
  const type = decision === "allow" ? "tool_execution" : "policy_deny";
  await env.EPISODES_DB.prepare(`
    INSERT INTO episodes (
      id, ts, type, run_id, step_id, policy_ref, policy_version,
      engine_ref, decision, reason, evidence_refs_json, payload_json
    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
  `).bind(
    requestId,
    ts,
    type,
    runId,
    stepId,
    policyRef,
    policyVersion,
    engineRef,
    decision,
    reason,
    JSON.stringify(evidenceRefs),
    JSON.stringify(payload)
  ).run();
}
__name(writeEpisode, "writeEpisode");
async function handleEpisodeSearch(request, env) {
  try {
    const body = await request.json();
    const limit = Math.min(Math.max(body.limit || 20, 1), 100);
    const order = body.order || "desc";
    const orderClause = order === "asc" ? "ASC" : "DESC";
    let query = "SELECT id, ts, type, run_id, step_id, policy_ref, policy_version, engine_ref, decision, reason, evidence_refs_json FROM episodes WHERE 1=1";
    const bindings = [];
    if (body.id) {
      query += " AND id = ?";
      bindings.push(body.id);
    }
    if (body.id_prefix) {
      query += " AND id LIKE ?";
      bindings.push(`${body.id_prefix}%`);
    }
    if (body.decision) {
      query += " AND decision = ?";
      bindings.push(body.decision);
    }
    if (body.type) {
      query += " AND type = ?";
      bindings.push(body.type);
    }
    if (body.since_ts) {
      query += " AND ts >= ?";
      bindings.push(body.since_ts);
    }
    if (body.until_ts) {
      query += " AND ts <= ?";
      bindings.push(body.until_ts);
    }
    query += ` ORDER BY ts ${orderClause} LIMIT ?`;
    bindings.push(limit);
    const stmt = env.EPISODES_DB.prepare(query);
    const result = await stmt.bind(...bindings).all();
    const results = (result.results || []).map((row) => {
      let evidenceRefs = [];
      try {
        evidenceRefs = JSON.parse(row.evidence_refs_json || "[]");
      } catch (e) {
        evidenceRefs = [];
      }
      return {
        id: row.id,
        ts: row.ts,
        type: row.type,
        run_id: row.run_id,
        step_id: row.step_id,
        policy_ref: row.policy_ref,
        policy_version: row.policy_version,
        engine_ref: row.engine_ref,
        decision: row.decision,
        reason: row.reason,
        evidence_refs: evidenceRefs
      };
    });
    return new Response(
      JSON.stringify({ ok: true, results }),
      { headers: { "Content-Type": "application/json" } }
    );
  } catch (error) {
    return new Response(
      JSON.stringify({ ok: false, error: error.message }),
      { status: 400, headers: { "Content-Type": "application/json" } }
    );
  }
}
__name(handleEpisodeSearch, "handleEpisodeSearch");
async function handleArtifactGet(request, env) {
  try {
    const url = new URL(request.url);
    const ref = url.searchParams.get("ref");
    if (!ref) {
      return new Response(
        JSON.stringify({ ok: false, error: "Missing ref parameter" }),
        { status: 400, headers: { "Content-Type": "application/json" } }
      );
    }
    if (ref.length > 512) {
      return new Response(
        JSON.stringify({ ok: false, error: "ref too long (max 512)" }),
        { status: 400, headers: { "Content-Type": "application/json" } }
      );
    }
    if (!/^[a-zA-Z0-9._/-]+$/.test(ref)) {
      return new Response(
        JSON.stringify({ ok: false, error: "Invalid ref format" }),
        { status: 400, headers: { "Content-Type": "application/json" } }
      );
    }
    if (ref.includes("..")) {
      return new Response(
        JSON.stringify({ ok: false, error: "ref must not contain .." }),
        { status: 400, headers: { "Content-Type": "application/json" } }
      );
    }
    if (ref.startsWith("/")) {
      return new Response(
        JSON.stringify({ ok: false, error: "ref must not start with /" }),
        { status: 400, headers: { "Content-Type": "application/json" } }
      );
    }
    const object = await env.ARTIFACTS.get(ref);
    if (!object) {
      return new Response(
        JSON.stringify({ ok: false, error: "Artifact not found" }),
        { status: 404, headers: { "Content-Type": "application/json" } }
      );
    }
    let contentType = "application/octet-stream";
    if (ref.endsWith(".json")) {
      contentType = "application/json";
    } else if (ref.endsWith(".jsonl")) {
      contentType = "application/x-ndjson";
    }
    const body = await object.arrayBuffer();
    return new Response(body, {
      headers: {
        "Content-Type": contentType,
        "Cache-Control": "no-store"
      }
    });
  } catch (error) {
    return new Response(
      JSON.stringify({ ok: false, error: error.message }),
      { status: 500, headers: { "Content-Type": "application/json" } }
    );
  }
}
__name(handleArtifactGet, "handleArtifactGet");
async function handleToolRun(request, env) {
  const body = await request.json();
  const requestId = body.request_id || body.envelope_id || `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  const toolId = body.tool_id;
  const args = body.args || {};
  const ctx = body.ctx || {};
  if (!toolId) {
    return new Response(
      JSON.stringify({ ok: false, error: "tool_id required" }),
      { status: 400, headers: { "Content-Type": "application/json" } }
    );
  }
  const runId = ctx.run_id || `run_${requestId}`;
  const stepId = ctx.step_id || `step_${requestId}`;
  const policyRef = ctx.policy_ref || env.DEFAULT_POLICY_REF;
  const policy = await loadPolicy(policyRef, env);
  if (!policy) {
    return new Response(
      JSON.stringify({ ok: false, error: `Policy ${policyRef} not found` }),
      { status: 404, headers: { "Content-Type": "application/json" } }
    );
  }
  const policyCheck = checkPolicy(toolId, args, policy);
  const engineIdentity = generateEngineIdentity(request, env);
  const engineRef = `${env.GATEWAY_VERSION}@${request.cf?.colo || "unknown"}`;
  const evidenceRefs = [];
  const timestamp = Date.now();
  const requestKey = `requests/${requestId}/request.json`;
  await env.ARTIFACTS.put(requestKey, JSON.stringify(body, null, 2));
  evidenceRefs.push(requestKey);
  const identityKey = `requests/${requestId}/engine_identity.json`;
  await env.ARTIFACTS.put(identityKey, JSON.stringify(engineIdentity, null, 2));
  evidenceRefs.push(identityKey);
  if (policyCheck.decision === "deny") {
    const decisionKey = `requests/${requestId}/policy_decision.json`;
    await env.ARTIFACTS.put(decisionKey, JSON.stringify(policyCheck, null, 2));
    evidenceRefs.push(decisionKey);
    await writeEpisode(
      requestId,
      runId,
      stepId,
      policyRef,
      policy.policy_version,
      engineRef,
      "deny",
      policyCheck.reason,
      evidenceRefs,
      { request: body, policy_check: policyCheck },
      env
    );
    const response = {
      ok: false,
      policy_check: policyCheck,
      evidence_refs: evidenceRefs,
      engine_ref: engineRef
    };
    return new Response(
      JSON.stringify(response, null, 2),
      { status: 403, headers: { "Content-Type": "application/json" } }
    );
  }
  const toolResult = await executeTool(toolId, args, env);
  const resultKey = `requests/${requestId}/tool_result.json`;
  await env.ARTIFACTS.put(resultKey, JSON.stringify(toolResult, null, 2));
  evidenceRefs.push(resultKey);
  const responseKey = `requests/${requestId}/response.json`;
  const gatewayResponse = {
    ok: true,
    tool_result: toolResult,
    policy_check: policyCheck,
    evidence_refs: evidenceRefs,
    engine_ref: engineRef
  };
  await env.ARTIFACTS.put(responseKey, JSON.stringify(gatewayResponse, null, 2));
  evidenceRefs.push(responseKey);
  await writeEpisode(
    requestId,
    runId,
    stepId,
    policyRef,
    policy.policy_version,
    engineRef,
    "allow",
    policyCheck.reason,
    evidenceRefs,
    { request: body, tool_result: toolResult, policy_check: policyCheck },
    env
  );
  return new Response(
    JSON.stringify(gatewayResponse, null, 2),
    { status: 200, headers: { "Content-Type": "application/json" } }
  );
}
__name(handleToolRun, "handleToolRun");
var index_default = {
  async fetch(request, env, ctx) {
    const url = new URL(request.url);
    if (url.pathname === "/health" && request.method === "GET") {
      const cf = request.cf || {};
      return new Response(
        JSON.stringify({
          ok: true,
          engine_ref: `${env.GATEWAY_VERSION}@${cf.colo || "unknown"}`,
          time: (/* @__PURE__ */ new Date()).toISOString()
        }),
        { headers: { "Content-Type": "application/json" } }
      );
    }
    if (url.pathname === "/tool/run" && request.method === "POST") {
      const authHeader = request.headers.get("Authorization");
      if (!authHeader || !authHeader.startsWith("Bearer ")) {
        return new Response(
          JSON.stringify({ ok: false, error: "Missing or invalid Authorization header" }),
          { status: 401, headers: { "Content-Type": "application/json" } }
        );
      }
      const token = authHeader.substring(7);
      if (token !== env.GATEWAY_AUTH_TOKEN) {
        return new Response(
          JSON.stringify({ ok: false, error: "Invalid auth token" }),
          { status: 401, headers: { "Content-Type": "application/json" } }
        );
      }
      return handleToolRun(request, env);
    }
    if (url.pathname === "/episode/search" && request.method === "POST") {
      const authHeader = request.headers.get("Authorization");
      if (!authHeader || !authHeader.startsWith("Bearer ")) {
        return new Response(
          JSON.stringify({ ok: false, error: "Missing or invalid Authorization header" }),
          { status: 401, headers: { "Content-Type": "application/json" } }
        );
      }
      const token = authHeader.substring(7);
      if (token !== env.GATEWAY_AUTH_TOKEN) {
        return new Response(
          JSON.stringify({ ok: false, error: "Invalid auth token" }),
          { status: 401, headers: { "Content-Type": "application/json" } }
        );
      }
      return handleEpisodeSearch(request, env);
    }
    if (url.pathname === "/artifact/get" && request.method === "GET") {
      const authHeader = request.headers.get("Authorization");
      if (!authHeader || !authHeader.startsWith("Bearer ")) {
        return new Response(
          JSON.stringify({ ok: false, error: "Missing or invalid Authorization header" }),
          { status: 401, headers: { "Content-Type": "application/json" } }
        );
      }
      const token = authHeader.substring(7);
      if (token !== env.GATEWAY_AUTH_TOKEN) {
        return new Response(
          JSON.stringify({ ok: false, error: "Invalid auth token" }),
          { status: 401, headers: { "Content-Type": "application/json" } }
        );
      }
      return handleArtifactGet(request, env);
    }
    if (url.pathname === "/schema/put" && request.method === "POST") {
      return handleSchemaPut(request, env);
    }
    if (url.pathname === "/schema/get" && request.method === "GET") {
      return handleSchemaGet(request, env);
    }
    if (url.pathname === "/payload/validate" && request.method === "POST") {
      return handlePayloadValidate(request, env);
    }
    return new Response(
      JSON.stringify({ ok: false, error: "Not found" }),
      { status: 404, headers: { "Content-Type": "application/json" } }
    );
  }
};
export {
  index_default as default
};
//# sourceMappingURL=index.js.map
