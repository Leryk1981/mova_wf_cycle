{
  "version": 3,
  "sources": ["../node_modules/@cfworker/json-schema/dist/deep-compare-strict.js", "../node_modules/@cfworker/json-schema/dist/pointer.js", "../node_modules/@cfworker/json-schema/dist/dereference.js", "../node_modules/@cfworker/json-schema/dist/format.js", "../node_modules/@cfworker/json-schema/dist/ucs2-length.js", "../node_modules/@cfworker/json-schema/dist/validate.js", "../node_modules/@cfworker/json-schema/dist/validator.js", "../src/index.ts"],
  "sourceRoot": ".tmp",
  "sourcesContent": ["export function deepCompareStrict(a, b) {\n    const typeofa = typeof a;\n    if (typeofa !== typeof b) {\n        return false;\n    }\n    if (Array.isArray(a)) {\n        if (!Array.isArray(b)) {\n            return false;\n        }\n        const length = a.length;\n        if (length !== b.length) {\n            return false;\n        }\n        for (let i = 0; i < length; i++) {\n            if (!deepCompareStrict(a[i], b[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    if (typeofa === 'object') {\n        if (!a || !b) {\n            return a === b;\n        }\n        const aKeys = Object.keys(a);\n        const bKeys = Object.keys(b);\n        const length = aKeys.length;\n        if (length !== bKeys.length) {\n            return false;\n        }\n        for (const k of aKeys) {\n            if (!deepCompareStrict(a[k], b[k])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return a === b;\n}\n", "export function encodePointer(p) {\n    return encodeURI(escapePointer(p));\n}\nexport function escapePointer(p) {\n    return p.replace(/~/g, '~0').replace(/\\//g, '~1');\n}\n", "import { encodePointer } from './pointer.js';\nexport const schemaKeyword = {\n    additionalItems: true,\n    unevaluatedItems: true,\n    items: true,\n    contains: true,\n    additionalProperties: true,\n    unevaluatedProperties: true,\n    propertyNames: true,\n    not: true,\n    if: true,\n    then: true,\n    else: true\n};\nexport const schemaArrayKeyword = {\n    prefixItems: true,\n    items: true,\n    allOf: true,\n    anyOf: true,\n    oneOf: true\n};\nexport const schemaMapKeyword = {\n    $defs: true,\n    definitions: true,\n    properties: true,\n    patternProperties: true,\n    dependentSchemas: true\n};\nexport const ignoredKeyword = {\n    id: true,\n    $id: true,\n    $ref: true,\n    $schema: true,\n    $anchor: true,\n    $vocabulary: true,\n    $comment: true,\n    default: true,\n    enum: true,\n    const: true,\n    required: true,\n    type: true,\n    maximum: true,\n    minimum: true,\n    exclusiveMaximum: true,\n    exclusiveMinimum: true,\n    multipleOf: true,\n    maxLength: true,\n    minLength: true,\n    pattern: true,\n    format: true,\n    maxItems: true,\n    minItems: true,\n    uniqueItems: true,\n    maxProperties: true,\n    minProperties: true\n};\nexport let initialBaseURI = typeof self !== 'undefined' &&\n    self.location &&\n    self.location.origin !== 'null'\n    ?\n        new URL(self.location.origin + self.location.pathname + location.search)\n    : new URL('https://github.com/cfworker');\nexport function dereference(schema, lookup = Object.create(null), baseURI = initialBaseURI, basePointer = '') {\n    if (schema && typeof schema === 'object' && !Array.isArray(schema)) {\n        const id = schema.$id || schema.id;\n        if (id) {\n            const url = new URL(id, baseURI.href);\n            if (url.hash.length > 1) {\n                lookup[url.href] = schema;\n            }\n            else {\n                url.hash = '';\n                if (basePointer === '') {\n                    baseURI = url;\n                }\n                else {\n                    dereference(schema, lookup, baseURI);\n                }\n            }\n        }\n    }\n    else if (schema !== true && schema !== false) {\n        return lookup;\n    }\n    const schemaURI = baseURI.href + (basePointer ? '#' + basePointer : '');\n    if (lookup[schemaURI] !== undefined) {\n        throw new Error(`Duplicate schema URI \"${schemaURI}\".`);\n    }\n    lookup[schemaURI] = schema;\n    if (schema === true || schema === false) {\n        return lookup;\n    }\n    if (schema.__absolute_uri__ === undefined) {\n        Object.defineProperty(schema, '__absolute_uri__', {\n            enumerable: false,\n            value: schemaURI\n        });\n    }\n    if (schema.$ref && schema.__absolute_ref__ === undefined) {\n        const url = new URL(schema.$ref, baseURI.href);\n        url.hash = url.hash;\n        Object.defineProperty(schema, '__absolute_ref__', {\n            enumerable: false,\n            value: url.href\n        });\n    }\n    if (schema.$recursiveRef && schema.__absolute_recursive_ref__ === undefined) {\n        const url = new URL(schema.$recursiveRef, baseURI.href);\n        url.hash = url.hash;\n        Object.defineProperty(schema, '__absolute_recursive_ref__', {\n            enumerable: false,\n            value: url.href\n        });\n    }\n    if (schema.$anchor) {\n        const url = new URL('#' + schema.$anchor, baseURI.href);\n        lookup[url.href] = schema;\n    }\n    for (let key in schema) {\n        if (ignoredKeyword[key]) {\n            continue;\n        }\n        const keyBase = `${basePointer}/${encodePointer(key)}`;\n        const subSchema = schema[key];\n        if (Array.isArray(subSchema)) {\n            if (schemaArrayKeyword[key]) {\n                const length = subSchema.length;\n                for (let i = 0; i < length; i++) {\n                    dereference(subSchema[i], lookup, baseURI, `${keyBase}/${i}`);\n                }\n            }\n        }\n        else if (schemaMapKeyword[key]) {\n            for (let subKey in subSchema) {\n                dereference(subSchema[subKey], lookup, baseURI, `${keyBase}/${encodePointer(subKey)}`);\n            }\n        }\n        else {\n            dereference(subSchema, lookup, baseURI, keyBase);\n        }\n    }\n    return lookup;\n}\n", "const DATE = /^(\\d\\d\\d\\d)-(\\d\\d)-(\\d\\d)$/;\nconst DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\nconst TIME = /^(\\d\\d):(\\d\\d):(\\d\\d)(\\.\\d+)?(z|[+-]\\d\\d(?::?\\d\\d)?)?$/i;\nconst HOSTNAME = /^(?=.{1,253}\\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\\.?$/i;\nconst URIREF = /^(?:[a-z][a-z0-9+\\-.]*:)?(?:\\/?\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\\.[a-z0-9\\-._~!$&'()*+,;=:]+)\\]|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)|(?:[a-z0-9\\-._~!$&'\"()*+,;=]|%[0-9a-f]{2})*)(?::\\d*)?(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*|\\/(?:(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\\?(?:[a-z0-9\\-._~!$&'\"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\\-._~!$&'\"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;\nconst URITEMPLATE = /^(?:(?:[^\\x00-\\x20\"'<>%\\\\^`{|}]|%[0-9a-f]{2})|\\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?)*\\})*$/i;\nconst URL_ = /^(?:(?:https?|ftp):\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?!10(?:\\.\\d{1,3}){3})(?!127(?:\\.\\d{1,3}){3})(?!169\\.254(?:\\.\\d{1,3}){2})(?!192\\.168(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u{00a1}-\\u{ffff}0-9]+-?)*[a-z\\u{00a1}-\\u{ffff}0-9]+)(?:\\.(?:[a-z\\u{00a1}-\\u{ffff}0-9]+-?)*[a-z\\u{00a1}-\\u{ffff}0-9]+)*(?:\\.(?:[a-z\\u{00a1}-\\u{ffff}]{2,})))(?::\\d{2,5})?(?:\\/[^\\s]*)?$/iu;\nconst UUID = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i;\nconst JSON_POINTER = /^(?:\\/(?:[^~/]|~0|~1)*)*$/;\nconst JSON_POINTER_URI_FRAGMENT = /^#(?:\\/(?:[a-z0-9_\\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i;\nconst RELATIVE_JSON_POINTER = /^(?:0|[1-9][0-9]*)(?:#|(?:\\/(?:[^~/]|~0|~1)*)*)$/;\nconst FASTDATE = /^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\d$/;\nconst FASTTIME = /^(?:[0-2]\\d:[0-5]\\d:[0-5]\\d|23:59:60)(?:\\.\\d+)?(?:z|[+-]\\d\\d(?::?\\d\\d)?)?$/i;\nconst FASTDATETIME = /^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\d[t\\s](?:[0-2]\\d:[0-5]\\d:[0-5]\\d|23:59:60)(?:\\.\\d+)?(?:z|[+-]\\d\\d(?::?\\d\\d)?)$/i;\nconst FASTURIREFERENCE = /^(?:(?:[a-z][a-z0-9+-.]*:)?\\/?\\/)?(?:[^\\\\\\s#][^\\s#]*)?(?:#[^\\\\\\s]*)?$/i;\nconst EMAIL = (input) => {\n    if (input[0] === '\"')\n        return false;\n    const [name, host, ...rest] = input.split('@');\n    if (!name ||\n        !host ||\n        rest.length !== 0 ||\n        name.length > 64 ||\n        host.length > 253)\n        return false;\n    if (name[0] === '.' || name.endsWith('.') || name.includes('..'))\n        return false;\n    if (!/^[a-z0-9.-]+$/i.test(host) ||\n        !/^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+$/i.test(name))\n        return false;\n    return host\n        .split('.')\n        .every(part => /^[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?$/i.test(part));\n};\nconst IPV4 = /^(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)$/;\nconst IPV6 = /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))$/i;\nconst DURATION = (input) => input.length > 1 &&\n    input.length < 80 &&\n    (/^P\\d+([.,]\\d+)?W$/.test(input) ||\n        (/^P[\\dYMDTHS]*(\\d[.,]\\d+)?[YMDHS]$/.test(input) &&\n            /^P([.,\\d]+Y)?([.,\\d]+M)?([.,\\d]+D)?(T([.,\\d]+H)?([.,\\d]+M)?([.,\\d]+S)?)?$/.test(input)));\nfunction bind(r) {\n    return r.test.bind(r);\n}\nexport const fullFormat = {\n    date,\n    time: time.bind(undefined, false),\n    'date-time': date_time,\n    duration: DURATION,\n    uri,\n    'uri-reference': bind(URIREF),\n    'uri-template': bind(URITEMPLATE),\n    url: bind(URL_),\n    email: EMAIL,\n    hostname: bind(HOSTNAME),\n    ipv4: bind(IPV4),\n    ipv6: bind(IPV6),\n    regex: regex,\n    uuid: bind(UUID),\n    'json-pointer': bind(JSON_POINTER),\n    'json-pointer-uri-fragment': bind(JSON_POINTER_URI_FRAGMENT),\n    'relative-json-pointer': bind(RELATIVE_JSON_POINTER)\n};\nexport const fastFormat = {\n    ...fullFormat,\n    date: bind(FASTDATE),\n    time: bind(FASTTIME),\n    'date-time': bind(FASTDATETIME),\n    'uri-reference': bind(FASTURIREFERENCE)\n};\nfunction isLeapYear(year) {\n    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);\n}\nfunction date(str) {\n    const matches = str.match(DATE);\n    if (!matches)\n        return false;\n    const year = +matches[1];\n    const month = +matches[2];\n    const day = +matches[3];\n    return (month >= 1 &&\n        month <= 12 &&\n        day >= 1 &&\n        day <= (month == 2 && isLeapYear(year) ? 29 : DAYS[month]));\n}\nfunction time(full, str) {\n    const matches = str.match(TIME);\n    if (!matches)\n        return false;\n    const hour = +matches[1];\n    const minute = +matches[2];\n    const second = +matches[3];\n    const timeZone = !!matches[5];\n    return (((hour <= 23 && minute <= 59 && second <= 59) ||\n        (hour == 23 && minute == 59 && second == 60)) &&\n        (!full || timeZone));\n}\nconst DATE_TIME_SEPARATOR = /t|\\s/i;\nfunction date_time(str) {\n    const dateTime = str.split(DATE_TIME_SEPARATOR);\n    return dateTime.length == 2 && date(dateTime[0]) && time(true, dateTime[1]);\n}\nconst NOT_URI_FRAGMENT = /\\/|:/;\nconst URI_PATTERN = /^(?:[a-z][a-z0-9+\\-.]*:)(?:\\/?\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\\.[a-z0-9\\-._~!$&'()*+,;=:]+)\\]|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)|(?:[a-z0-9\\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\\d*)?(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\\?(?:[a-z0-9\\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;\nfunction uri(str) {\n    return NOT_URI_FRAGMENT.test(str) && URI_PATTERN.test(str);\n}\nconst Z_ANCHOR = /[^\\\\]\\\\Z/;\nfunction regex(str) {\n    if (Z_ANCHOR.test(str))\n        return false;\n    try {\n        new RegExp(str, 'u');\n        return true;\n    }\n    catch (e) {\n        return false;\n    }\n}\n", "export function ucs2length(s) {\n    let result = 0;\n    let length = s.length;\n    let index = 0;\n    let charCode;\n    while (index < length) {\n        result++;\n        charCode = s.charCodeAt(index++);\n        if (charCode >= 0xd800 && charCode <= 0xdbff && index < length) {\n            charCode = s.charCodeAt(index);\n            if ((charCode & 0xfc00) == 0xdc00) {\n                index++;\n            }\n        }\n    }\n    return result;\n}\n", "import { deepCompareStrict } from './deep-compare-strict.js';\nimport { dereference } from './dereference.js';\nimport { fastFormat } from './format.js';\nimport { encodePointer } from './pointer.js';\nimport { ucs2length } from './ucs2-length.js';\nexport function validate(instance, schema, draft = '2019-09', lookup = dereference(schema), shortCircuit = true, recursiveAnchor = null, instanceLocation = '#', schemaLocation = '#', evaluated = Object.create(null)) {\n    if (schema === true) {\n        return { valid: true, errors: [] };\n    }\n    if (schema === false) {\n        return {\n            valid: false,\n            errors: [\n                {\n                    instanceLocation,\n                    keyword: 'false',\n                    keywordLocation: instanceLocation,\n                    error: 'False boolean schema.'\n                }\n            ]\n        };\n    }\n    const rawInstanceType = typeof instance;\n    let instanceType;\n    switch (rawInstanceType) {\n        case 'boolean':\n        case 'number':\n        case 'string':\n            instanceType = rawInstanceType;\n            break;\n        case 'object':\n            if (instance === null) {\n                instanceType = 'null';\n            }\n            else if (Array.isArray(instance)) {\n                instanceType = 'array';\n            }\n            else {\n                instanceType = 'object';\n            }\n            break;\n        default:\n            throw new Error(`Instances of \"${rawInstanceType}\" type are not supported.`);\n    }\n    const { $ref, $recursiveRef, $recursiveAnchor, type: $type, const: $const, enum: $enum, required: $required, not: $not, anyOf: $anyOf, allOf: $allOf, oneOf: $oneOf, if: $if, then: $then, else: $else, format: $format, properties: $properties, patternProperties: $patternProperties, additionalProperties: $additionalProperties, unevaluatedProperties: $unevaluatedProperties, minProperties: $minProperties, maxProperties: $maxProperties, propertyNames: $propertyNames, dependentRequired: $dependentRequired, dependentSchemas: $dependentSchemas, dependencies: $dependencies, prefixItems: $prefixItems, items: $items, additionalItems: $additionalItems, unevaluatedItems: $unevaluatedItems, contains: $contains, minContains: $minContains, maxContains: $maxContains, minItems: $minItems, maxItems: $maxItems, uniqueItems: $uniqueItems, minimum: $minimum, maximum: $maximum, exclusiveMinimum: $exclusiveMinimum, exclusiveMaximum: $exclusiveMaximum, multipleOf: $multipleOf, minLength: $minLength, maxLength: $maxLength, pattern: $pattern, __absolute_ref__, __absolute_recursive_ref__ } = schema;\n    const errors = [];\n    if ($recursiveAnchor === true && recursiveAnchor === null) {\n        recursiveAnchor = schema;\n    }\n    if ($recursiveRef === '#') {\n        const refSchema = recursiveAnchor === null\n            ? lookup[__absolute_recursive_ref__]\n            : recursiveAnchor;\n        const keywordLocation = `${schemaLocation}/$recursiveRef`;\n        const result = validate(instance, recursiveAnchor === null ? schema : recursiveAnchor, draft, lookup, shortCircuit, refSchema, instanceLocation, keywordLocation, evaluated);\n        if (!result.valid) {\n            errors.push({\n                instanceLocation,\n                keyword: '$recursiveRef',\n                keywordLocation,\n                error: 'A subschema had errors.'\n            }, ...result.errors);\n        }\n    }\n    if ($ref !== undefined) {\n        const uri = __absolute_ref__ || $ref;\n        const refSchema = lookup[uri];\n        if (refSchema === undefined) {\n            let message = `Unresolved $ref \"${$ref}\".`;\n            if (__absolute_ref__ && __absolute_ref__ !== $ref) {\n                message += `  Absolute URI \"${__absolute_ref__}\".`;\n            }\n            message += `\\nKnown schemas:\\n- ${Object.keys(lookup).join('\\n- ')}`;\n            throw new Error(message);\n        }\n        const keywordLocation = `${schemaLocation}/$ref`;\n        const result = validate(instance, refSchema, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, keywordLocation, evaluated);\n        if (!result.valid) {\n            errors.push({\n                instanceLocation,\n                keyword: '$ref',\n                keywordLocation,\n                error: 'A subschema had errors.'\n            }, ...result.errors);\n        }\n        if (draft === '4' || draft === '7') {\n            return { valid: errors.length === 0, errors };\n        }\n    }\n    if (Array.isArray($type)) {\n        let length = $type.length;\n        let valid = false;\n        for (let i = 0; i < length; i++) {\n            if (instanceType === $type[i] ||\n                ($type[i] === 'integer' &&\n                    instanceType === 'number' &&\n                    instance % 1 === 0 &&\n                    instance === instance)) {\n                valid = true;\n                break;\n            }\n        }\n        if (!valid) {\n            errors.push({\n                instanceLocation,\n                keyword: 'type',\n                keywordLocation: `${schemaLocation}/type`,\n                error: `Instance type \"${instanceType}\" is invalid. Expected \"${$type.join('\", \"')}\".`\n            });\n        }\n    }\n    else if ($type === 'integer') {\n        if (instanceType !== 'number' || instance % 1 || instance !== instance) {\n            errors.push({\n                instanceLocation,\n                keyword: 'type',\n                keywordLocation: `${schemaLocation}/type`,\n                error: `Instance type \"${instanceType}\" is invalid. Expected \"${$type}\".`\n            });\n        }\n    }\n    else if ($type !== undefined && instanceType !== $type) {\n        errors.push({\n            instanceLocation,\n            keyword: 'type',\n            keywordLocation: `${schemaLocation}/type`,\n            error: `Instance type \"${instanceType}\" is invalid. Expected \"${$type}\".`\n        });\n    }\n    if ($const !== undefined) {\n        if (instanceType === 'object' || instanceType === 'array') {\n            if (!deepCompareStrict(instance, $const)) {\n                errors.push({\n                    instanceLocation,\n                    keyword: 'const',\n                    keywordLocation: `${schemaLocation}/const`,\n                    error: `Instance does not match ${JSON.stringify($const)}.`\n                });\n            }\n        }\n        else if (instance !== $const) {\n            errors.push({\n                instanceLocation,\n                keyword: 'const',\n                keywordLocation: `${schemaLocation}/const`,\n                error: `Instance does not match ${JSON.stringify($const)}.`\n            });\n        }\n    }\n    if ($enum !== undefined) {\n        if (instanceType === 'object' || instanceType === 'array') {\n            if (!$enum.some(value => deepCompareStrict(instance, value))) {\n                errors.push({\n                    instanceLocation,\n                    keyword: 'enum',\n                    keywordLocation: `${schemaLocation}/enum`,\n                    error: `Instance does not match any of ${JSON.stringify($enum)}.`\n                });\n            }\n        }\n        else if (!$enum.some(value => instance === value)) {\n            errors.push({\n                instanceLocation,\n                keyword: 'enum',\n                keywordLocation: `${schemaLocation}/enum`,\n                error: `Instance does not match any of ${JSON.stringify($enum)}.`\n            });\n        }\n    }\n    if ($not !== undefined) {\n        const keywordLocation = `${schemaLocation}/not`;\n        const result = validate(instance, $not, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, keywordLocation);\n        if (result.valid) {\n            errors.push({\n                instanceLocation,\n                keyword: 'not',\n                keywordLocation,\n                error: 'Instance matched \"not\" schema.'\n            });\n        }\n    }\n    let subEvaluateds = [];\n    if ($anyOf !== undefined) {\n        const keywordLocation = `${schemaLocation}/anyOf`;\n        const errorsLength = errors.length;\n        let anyValid = false;\n        for (let i = 0; i < $anyOf.length; i++) {\n            const subSchema = $anyOf[i];\n            const subEvaluated = Object.create(evaluated);\n            const result = validate(instance, subSchema, draft, lookup, shortCircuit, $recursiveAnchor === true ? recursiveAnchor : null, instanceLocation, `${keywordLocation}/${i}`, subEvaluated);\n            errors.push(...result.errors);\n            anyValid = anyValid || result.valid;\n            if (result.valid) {\n                subEvaluateds.push(subEvaluated);\n            }\n        }\n        if (anyValid) {\n            errors.length = errorsLength;\n        }\n        else {\n            errors.splice(errorsLength, 0, {\n                instanceLocation,\n                keyword: 'anyOf',\n                keywordLocation,\n                error: 'Instance does not match any subschemas.'\n            });\n        }\n    }\n    if ($allOf !== undefined) {\n        const keywordLocation = `${schemaLocation}/allOf`;\n        const errorsLength = errors.length;\n        let allValid = true;\n        for (let i = 0; i < $allOf.length; i++) {\n            const subSchema = $allOf[i];\n            const subEvaluated = Object.create(evaluated);\n            const result = validate(instance, subSchema, draft, lookup, shortCircuit, $recursiveAnchor === true ? recursiveAnchor : null, instanceLocation, `${keywordLocation}/${i}`, subEvaluated);\n            errors.push(...result.errors);\n            allValid = allValid && result.valid;\n            if (result.valid) {\n                subEvaluateds.push(subEvaluated);\n            }\n        }\n        if (allValid) {\n            errors.length = errorsLength;\n        }\n        else {\n            errors.splice(errorsLength, 0, {\n                instanceLocation,\n                keyword: 'allOf',\n                keywordLocation,\n                error: `Instance does not match every subschema.`\n            });\n        }\n    }\n    if ($oneOf !== undefined) {\n        const keywordLocation = `${schemaLocation}/oneOf`;\n        const errorsLength = errors.length;\n        const matches = $oneOf.filter((subSchema, i) => {\n            const subEvaluated = Object.create(evaluated);\n            const result = validate(instance, subSchema, draft, lookup, shortCircuit, $recursiveAnchor === true ? recursiveAnchor : null, instanceLocation, `${keywordLocation}/${i}`, subEvaluated);\n            errors.push(...result.errors);\n            if (result.valid) {\n                subEvaluateds.push(subEvaluated);\n            }\n            return result.valid;\n        }).length;\n        if (matches === 1) {\n            errors.length = errorsLength;\n        }\n        else {\n            errors.splice(errorsLength, 0, {\n                instanceLocation,\n                keyword: 'oneOf',\n                keywordLocation,\n                error: `Instance does not match exactly one subschema (${matches} matches).`\n            });\n        }\n    }\n    if (instanceType === 'object' || instanceType === 'array') {\n        Object.assign(evaluated, ...subEvaluateds);\n    }\n    if ($if !== undefined) {\n        const keywordLocation = `${schemaLocation}/if`;\n        const conditionResult = validate(instance, $if, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, keywordLocation, evaluated).valid;\n        if (conditionResult) {\n            if ($then !== undefined) {\n                const thenResult = validate(instance, $then, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, `${schemaLocation}/then`, evaluated);\n                if (!thenResult.valid) {\n                    errors.push({\n                        instanceLocation,\n                        keyword: 'if',\n                        keywordLocation,\n                        error: `Instance does not match \"then\" schema.`\n                    }, ...thenResult.errors);\n                }\n            }\n        }\n        else if ($else !== undefined) {\n            const elseResult = validate(instance, $else, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, `${schemaLocation}/else`, evaluated);\n            if (!elseResult.valid) {\n                errors.push({\n                    instanceLocation,\n                    keyword: 'if',\n                    keywordLocation,\n                    error: `Instance does not match \"else\" schema.`\n                }, ...elseResult.errors);\n            }\n        }\n    }\n    if (instanceType === 'object') {\n        if ($required !== undefined) {\n            for (const key of $required) {\n                if (!(key in instance)) {\n                    errors.push({\n                        instanceLocation,\n                        keyword: 'required',\n                        keywordLocation: `${schemaLocation}/required`,\n                        error: `Instance does not have required property \"${key}\".`\n                    });\n                }\n            }\n        }\n        const keys = Object.keys(instance);\n        if ($minProperties !== undefined && keys.length < $minProperties) {\n            errors.push({\n                instanceLocation,\n                keyword: 'minProperties',\n                keywordLocation: `${schemaLocation}/minProperties`,\n                error: `Instance does not have at least ${$minProperties} properties.`\n            });\n        }\n        if ($maxProperties !== undefined && keys.length > $maxProperties) {\n            errors.push({\n                instanceLocation,\n                keyword: 'maxProperties',\n                keywordLocation: `${schemaLocation}/maxProperties`,\n                error: `Instance does not have at least ${$maxProperties} properties.`\n            });\n        }\n        if ($propertyNames !== undefined) {\n            const keywordLocation = `${schemaLocation}/propertyNames`;\n            for (const key in instance) {\n                const subInstancePointer = `${instanceLocation}/${encodePointer(key)}`;\n                const result = validate(key, $propertyNames, draft, lookup, shortCircuit, recursiveAnchor, subInstancePointer, keywordLocation);\n                if (!result.valid) {\n                    errors.push({\n                        instanceLocation,\n                        keyword: 'propertyNames',\n                        keywordLocation,\n                        error: `Property name \"${key}\" does not match schema.`\n                    }, ...result.errors);\n                }\n            }\n        }\n        if ($dependentRequired !== undefined) {\n            const keywordLocation = `${schemaLocation}/dependantRequired`;\n            for (const key in $dependentRequired) {\n                if (key in instance) {\n                    const required = $dependentRequired[key];\n                    for (const dependantKey of required) {\n                        if (!(dependantKey in instance)) {\n                            errors.push({\n                                instanceLocation,\n                                keyword: 'dependentRequired',\n                                keywordLocation,\n                                error: `Instance has \"${key}\" but does not have \"${dependantKey}\".`\n                            });\n                        }\n                    }\n                }\n            }\n        }\n        if ($dependentSchemas !== undefined) {\n            for (const key in $dependentSchemas) {\n                const keywordLocation = `${schemaLocation}/dependentSchemas`;\n                if (key in instance) {\n                    const result = validate(instance, $dependentSchemas[key], draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, `${keywordLocation}/${encodePointer(key)}`, evaluated);\n                    if (!result.valid) {\n                        errors.push({\n                            instanceLocation,\n                            keyword: 'dependentSchemas',\n                            keywordLocation,\n                            error: `Instance has \"${key}\" but does not match dependant schema.`\n                        }, ...result.errors);\n                    }\n                }\n            }\n        }\n        if ($dependencies !== undefined) {\n            const keywordLocation = `${schemaLocation}/dependencies`;\n            for (const key in $dependencies) {\n                if (key in instance) {\n                    const propsOrSchema = $dependencies[key];\n                    if (Array.isArray(propsOrSchema)) {\n                        for (const dependantKey of propsOrSchema) {\n                            if (!(dependantKey in instance)) {\n                                errors.push({\n                                    instanceLocation,\n                                    keyword: 'dependencies',\n                                    keywordLocation,\n                                    error: `Instance has \"${key}\" but does not have \"${dependantKey}\".`\n                                });\n                            }\n                        }\n                    }\n                    else {\n                        const result = validate(instance, propsOrSchema, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, `${keywordLocation}/${encodePointer(key)}`);\n                        if (!result.valid) {\n                            errors.push({\n                                instanceLocation,\n                                keyword: 'dependencies',\n                                keywordLocation,\n                                error: `Instance has \"${key}\" but does not match dependant schema.`\n                            }, ...result.errors);\n                        }\n                    }\n                }\n            }\n        }\n        const thisEvaluated = Object.create(null);\n        let stop = false;\n        if ($properties !== undefined) {\n            const keywordLocation = `${schemaLocation}/properties`;\n            for (const key in $properties) {\n                if (!(key in instance)) {\n                    continue;\n                }\n                const subInstancePointer = `${instanceLocation}/${encodePointer(key)}`;\n                const result = validate(instance[key], $properties[key], draft, lookup, shortCircuit, recursiveAnchor, subInstancePointer, `${keywordLocation}/${encodePointer(key)}`);\n                if (result.valid) {\n                    evaluated[key] = thisEvaluated[key] = true;\n                }\n                else {\n                    stop = shortCircuit;\n                    errors.push({\n                        instanceLocation,\n                        keyword: 'properties',\n                        keywordLocation,\n                        error: `Property \"${key}\" does not match schema.`\n                    }, ...result.errors);\n                    if (stop)\n                        break;\n                }\n            }\n        }\n        if (!stop && $patternProperties !== undefined) {\n            const keywordLocation = `${schemaLocation}/patternProperties`;\n            for (const pattern in $patternProperties) {\n                const regex = new RegExp(pattern, 'u');\n                const subSchema = $patternProperties[pattern];\n                for (const key in instance) {\n                    if (!regex.test(key)) {\n                        continue;\n                    }\n                    const subInstancePointer = `${instanceLocation}/${encodePointer(key)}`;\n                    const result = validate(instance[key], subSchema, draft, lookup, shortCircuit, recursiveAnchor, subInstancePointer, `${keywordLocation}/${encodePointer(pattern)}`);\n                    if (result.valid) {\n                        evaluated[key] = thisEvaluated[key] = true;\n                    }\n                    else {\n                        stop = shortCircuit;\n                        errors.push({\n                            instanceLocation,\n                            keyword: 'patternProperties',\n                            keywordLocation,\n                            error: `Property \"${key}\" matches pattern \"${pattern}\" but does not match associated schema.`\n                        }, ...result.errors);\n                    }\n                }\n            }\n        }\n        if (!stop && $additionalProperties !== undefined) {\n            const keywordLocation = `${schemaLocation}/additionalProperties`;\n            for (const key in instance) {\n                if (thisEvaluated[key]) {\n                    continue;\n                }\n                const subInstancePointer = `${instanceLocation}/${encodePointer(key)}`;\n                const result = validate(instance[key], $additionalProperties, draft, lookup, shortCircuit, recursiveAnchor, subInstancePointer, keywordLocation);\n                if (result.valid) {\n                    evaluated[key] = true;\n                }\n                else {\n                    stop = shortCircuit;\n                    errors.push({\n                        instanceLocation,\n                        keyword: 'additionalProperties',\n                        keywordLocation,\n                        error: `Property \"${key}\" does not match additional properties schema.`\n                    }, ...result.errors);\n                }\n            }\n        }\n        else if (!stop && $unevaluatedProperties !== undefined) {\n            const keywordLocation = `${schemaLocation}/unevaluatedProperties`;\n            for (const key in instance) {\n                if (!evaluated[key]) {\n                    const subInstancePointer = `${instanceLocation}/${encodePointer(key)}`;\n                    const result = validate(instance[key], $unevaluatedProperties, draft, lookup, shortCircuit, recursiveAnchor, subInstancePointer, keywordLocation);\n                    if (result.valid) {\n                        evaluated[key] = true;\n                    }\n                    else {\n                        errors.push({\n                            instanceLocation,\n                            keyword: 'unevaluatedProperties',\n                            keywordLocation,\n                            error: `Property \"${key}\" does not match unevaluated properties schema.`\n                        }, ...result.errors);\n                    }\n                }\n            }\n        }\n    }\n    else if (instanceType === 'array') {\n        if ($maxItems !== undefined && instance.length > $maxItems) {\n            errors.push({\n                instanceLocation,\n                keyword: 'maxItems',\n                keywordLocation: `${schemaLocation}/maxItems`,\n                error: `Array has too many items (${instance.length} > ${$maxItems}).`\n            });\n        }\n        if ($minItems !== undefined && instance.length < $minItems) {\n            errors.push({\n                instanceLocation,\n                keyword: 'minItems',\n                keywordLocation: `${schemaLocation}/minItems`,\n                error: `Array has too few items (${instance.length} < ${$minItems}).`\n            });\n        }\n        const length = instance.length;\n        let i = 0;\n        let stop = false;\n        if ($prefixItems !== undefined) {\n            const keywordLocation = `${schemaLocation}/prefixItems`;\n            const length2 = Math.min($prefixItems.length, length);\n            for (; i < length2; i++) {\n                const result = validate(instance[i], $prefixItems[i], draft, lookup, shortCircuit, recursiveAnchor, `${instanceLocation}/${i}`, `${keywordLocation}/${i}`);\n                evaluated[i] = true;\n                if (!result.valid) {\n                    stop = shortCircuit;\n                    errors.push({\n                        instanceLocation,\n                        keyword: 'prefixItems',\n                        keywordLocation,\n                        error: `Items did not match schema.`\n                    }, ...result.errors);\n                    if (stop)\n                        break;\n                }\n            }\n        }\n        if ($items !== undefined) {\n            const keywordLocation = `${schemaLocation}/items`;\n            if (Array.isArray($items)) {\n                const length2 = Math.min($items.length, length);\n                for (; i < length2; i++) {\n                    const result = validate(instance[i], $items[i], draft, lookup, shortCircuit, recursiveAnchor, `${instanceLocation}/${i}`, `${keywordLocation}/${i}`);\n                    evaluated[i] = true;\n                    if (!result.valid) {\n                        stop = shortCircuit;\n                        errors.push({\n                            instanceLocation,\n                            keyword: 'items',\n                            keywordLocation,\n                            error: `Items did not match schema.`\n                        }, ...result.errors);\n                        if (stop)\n                            break;\n                    }\n                }\n            }\n            else {\n                for (; i < length; i++) {\n                    const result = validate(instance[i], $items, draft, lookup, shortCircuit, recursiveAnchor, `${instanceLocation}/${i}`, keywordLocation);\n                    evaluated[i] = true;\n                    if (!result.valid) {\n                        stop = shortCircuit;\n                        errors.push({\n                            instanceLocation,\n                            keyword: 'items',\n                            keywordLocation,\n                            error: `Items did not match schema.`\n                        }, ...result.errors);\n                        if (stop)\n                            break;\n                    }\n                }\n            }\n            if (!stop && $additionalItems !== undefined) {\n                const keywordLocation = `${schemaLocation}/additionalItems`;\n                for (; i < length; i++) {\n                    const result = validate(instance[i], $additionalItems, draft, lookup, shortCircuit, recursiveAnchor, `${instanceLocation}/${i}`, keywordLocation);\n                    evaluated[i] = true;\n                    if (!result.valid) {\n                        stop = shortCircuit;\n                        errors.push({\n                            instanceLocation,\n                            keyword: 'additionalItems',\n                            keywordLocation,\n                            error: `Items did not match additional items schema.`\n                        }, ...result.errors);\n                    }\n                }\n            }\n        }\n        if ($contains !== undefined) {\n            if (length === 0 && $minContains === undefined) {\n                errors.push({\n                    instanceLocation,\n                    keyword: 'contains',\n                    keywordLocation: `${schemaLocation}/contains`,\n                    error: `Array is empty. It must contain at least one item matching the schema.`\n                });\n            }\n            else if ($minContains !== undefined && length < $minContains) {\n                errors.push({\n                    instanceLocation,\n                    keyword: 'minContains',\n                    keywordLocation: `${schemaLocation}/minContains`,\n                    error: `Array has less items (${length}) than minContains (${$minContains}).`\n                });\n            }\n            else {\n                const keywordLocation = `${schemaLocation}/contains`;\n                const errorsLength = errors.length;\n                let contained = 0;\n                for (let j = 0; j < length; j++) {\n                    const result = validate(instance[j], $contains, draft, lookup, shortCircuit, recursiveAnchor, `${instanceLocation}/${j}`, keywordLocation);\n                    if (result.valid) {\n                        evaluated[j] = true;\n                        contained++;\n                    }\n                    else {\n                        errors.push(...result.errors);\n                    }\n                }\n                if (contained >= ($minContains || 0)) {\n                    errors.length = errorsLength;\n                }\n                if ($minContains === undefined &&\n                    $maxContains === undefined &&\n                    contained === 0) {\n                    errors.splice(errorsLength, 0, {\n                        instanceLocation,\n                        keyword: 'contains',\n                        keywordLocation,\n                        error: `Array does not contain item matching schema.`\n                    });\n                }\n                else if ($minContains !== undefined && contained < $minContains) {\n                    errors.push({\n                        instanceLocation,\n                        keyword: 'minContains',\n                        keywordLocation: `${schemaLocation}/minContains`,\n                        error: `Array must contain at least ${$minContains} items matching schema. Only ${contained} items were found.`\n                    });\n                }\n                else if ($maxContains !== undefined && contained > $maxContains) {\n                    errors.push({\n                        instanceLocation,\n                        keyword: 'maxContains',\n                        keywordLocation: `${schemaLocation}/maxContains`,\n                        error: `Array may contain at most ${$maxContains} items matching schema. ${contained} items were found.`\n                    });\n                }\n            }\n        }\n        if (!stop && $unevaluatedItems !== undefined) {\n            const keywordLocation = `${schemaLocation}/unevaluatedItems`;\n            for (i; i < length; i++) {\n                if (evaluated[i]) {\n                    continue;\n                }\n                const result = validate(instance[i], $unevaluatedItems, draft, lookup, shortCircuit, recursiveAnchor, `${instanceLocation}/${i}`, keywordLocation);\n                evaluated[i] = true;\n                if (!result.valid) {\n                    errors.push({\n                        instanceLocation,\n                        keyword: 'unevaluatedItems',\n                        keywordLocation,\n                        error: `Items did not match unevaluated items schema.`\n                    }, ...result.errors);\n                }\n            }\n        }\n        if ($uniqueItems) {\n            for (let j = 0; j < length; j++) {\n                const a = instance[j];\n                const ao = typeof a === 'object' && a !== null;\n                for (let k = 0; k < length; k++) {\n                    if (j === k) {\n                        continue;\n                    }\n                    const b = instance[k];\n                    const bo = typeof b === 'object' && b !== null;\n                    if (a === b || (ao && bo && deepCompareStrict(a, b))) {\n                        errors.push({\n                            instanceLocation,\n                            keyword: 'uniqueItems',\n                            keywordLocation: `${schemaLocation}/uniqueItems`,\n                            error: `Duplicate items at indexes ${j} and ${k}.`\n                        });\n                        j = Number.MAX_SAFE_INTEGER;\n                        k = Number.MAX_SAFE_INTEGER;\n                    }\n                }\n            }\n        }\n    }\n    else if (instanceType === 'number') {\n        if (draft === '4') {\n            if ($minimum !== undefined &&\n                (($exclusiveMinimum === true && instance <= $minimum) ||\n                    instance < $minimum)) {\n                errors.push({\n                    instanceLocation,\n                    keyword: 'minimum',\n                    keywordLocation: `${schemaLocation}/minimum`,\n                    error: `${instance} is less than ${$exclusiveMinimum ? 'or equal to ' : ''} ${$minimum}.`\n                });\n            }\n            if ($maximum !== undefined &&\n                (($exclusiveMaximum === true && instance >= $maximum) ||\n                    instance > $maximum)) {\n                errors.push({\n                    instanceLocation,\n                    keyword: 'maximum',\n                    keywordLocation: `${schemaLocation}/maximum`,\n                    error: `${instance} is greater than ${$exclusiveMaximum ? 'or equal to ' : ''} ${$maximum}.`\n                });\n            }\n        }\n        else {\n            if ($minimum !== undefined && instance < $minimum) {\n                errors.push({\n                    instanceLocation,\n                    keyword: 'minimum',\n                    keywordLocation: `${schemaLocation}/minimum`,\n                    error: `${instance} is less than ${$minimum}.`\n                });\n            }\n            if ($maximum !== undefined && instance > $maximum) {\n                errors.push({\n                    instanceLocation,\n                    keyword: 'maximum',\n                    keywordLocation: `${schemaLocation}/maximum`,\n                    error: `${instance} is greater than ${$maximum}.`\n                });\n            }\n            if ($exclusiveMinimum !== undefined && instance <= $exclusiveMinimum) {\n                errors.push({\n                    instanceLocation,\n                    keyword: 'exclusiveMinimum',\n                    keywordLocation: `${schemaLocation}/exclusiveMinimum`,\n                    error: `${instance} is less than ${$exclusiveMinimum}.`\n                });\n            }\n            if ($exclusiveMaximum !== undefined && instance >= $exclusiveMaximum) {\n                errors.push({\n                    instanceLocation,\n                    keyword: 'exclusiveMaximum',\n                    keywordLocation: `${schemaLocation}/exclusiveMaximum`,\n                    error: `${instance} is greater than or equal to ${$exclusiveMaximum}.`\n                });\n            }\n        }\n        if ($multipleOf !== undefined) {\n            const remainder = instance % $multipleOf;\n            if (Math.abs(0 - remainder) >= 1.1920929e-7 &&\n                Math.abs($multipleOf - remainder) >= 1.1920929e-7) {\n                errors.push({\n                    instanceLocation,\n                    keyword: 'multipleOf',\n                    keywordLocation: `${schemaLocation}/multipleOf`,\n                    error: `${instance} is not a multiple of ${$multipleOf}.`\n                });\n            }\n        }\n    }\n    else if (instanceType === 'string') {\n        const length = $minLength === undefined && $maxLength === undefined\n            ? 0\n            : ucs2length(instance);\n        if ($minLength !== undefined && length < $minLength) {\n            errors.push({\n                instanceLocation,\n                keyword: 'minLength',\n                keywordLocation: `${schemaLocation}/minLength`,\n                error: `String is too short (${length} < ${$minLength}).`\n            });\n        }\n        if ($maxLength !== undefined && length > $maxLength) {\n            errors.push({\n                instanceLocation,\n                keyword: 'maxLength',\n                keywordLocation: `${schemaLocation}/maxLength`,\n                error: `String is too long (${length} > ${$maxLength}).`\n            });\n        }\n        if ($pattern !== undefined && !new RegExp($pattern, 'u').test(instance)) {\n            errors.push({\n                instanceLocation,\n                keyword: 'pattern',\n                keywordLocation: `${schemaLocation}/pattern`,\n                error: `String does not match pattern.`\n            });\n        }\n        if ($format !== undefined &&\n            fastFormat[$format] &&\n            !fastFormat[$format](instance)) {\n            errors.push({\n                instanceLocation,\n                keyword: 'format',\n                keywordLocation: `${schemaLocation}/format`,\n                error: `String does not match format \"${$format}\".`\n            });\n        }\n    }\n    return { valid: errors.length === 0, errors };\n}\n", "import { dereference } from './dereference.js';\nimport { validate } from './validate.js';\nexport class Validator {\n    constructor(schema, draft = '2019-09', shortCircuit = true) {\n        this.schema = schema;\n        this.draft = draft;\n        this.shortCircuit = shortCircuit;\n        this.lookup = dereference(schema);\n    }\n    validate(instance) {\n        return validate(instance, this.schema, this.draft, this.lookup, this.shortCircuit);\n    }\n    addSchema(schema, id) {\n        if (id) {\n            schema = { ...schema, $id: id };\n        }\n        dereference(schema, this.lookup);\n    }\n}\n", "/**\r\n * MOVA Cloudflare Worker Tool Gateway v0\r\n * \r\n * Executor gateway that handles tool execution requests with:\r\n * - Policy checking (deny-by-default, allowlist)\r\n * - Evidence collection (R2 artifacts, D1 episodes)\r\n * - Tool execution (v0: kv.get, http.fetch GET only)\r\n * - Schema registry and payload validation (WF_EX_SCHEMA_PAYLOAD_002)\r\n */\r\n\r\nimport { Validator } from '@cfworker/json-schema';\r\n\r\ninterface Env {\r\n  POLICY_KV: any; // KVNamespace\r\n  EPISODES_DB: any; // D1Database\r\n  ARTIFACTS: any; // R2Bucket\r\n  GATEWAY_VERSION: string;\r\n  GATEWAY_AUTH_TOKEN: string;\r\n  DEFAULT_POLICY_REF: string;\r\n  ADMIN_AUTH_TOKEN?: string; // Optional admin token for V2 inline schema\r\n  ALLOW_INLINE_SCHEMA?: string; // \"true\" to allow inline schema in dev\r\n}\r\n\r\ninterface ToolRequest {\r\n  request_id?: string;\r\n  envelope_id?: string;\r\n  tool_id: string;\r\n  args: Record<string, any>;\r\n  ctx?: {\r\n    run_id?: string;\r\n    step_id?: string;\r\n    policy_ref?: string;\r\n  };\r\n}\r\n\r\ninterface PolicyProfile {\r\n  policy_id: string;\r\n  policy_version: string;\r\n  default_decision: 'allow' | 'deny';\r\n  tool_allowlist?: string[];\r\n  http_fetch_hostname_allowlist?: string[];\r\n}\r\n\r\ninterface ToolResult {\r\n  exit_code: number;\r\n  stdout: string;\r\n  stderr: string;\r\n  data?: any;\r\n  status?: number;\r\n  headers?: Record<string, string>;\r\n}\r\n\r\ninterface GatewayResponse {\r\n  ok: boolean;\r\n  tool_result?: ToolResult;\r\n  policy_check?: {\r\n    decision: 'allow' | 'deny';\r\n    reason: string;\r\n    rule_id?: string;\r\n  };\r\n  evidence_refs?: string[];\r\n  engine_ref: string;\r\n}\r\n\r\n// Schema registry interfaces\r\ninterface SchemaPutRequest {\r\n  schema_id: string;\r\n  version: string;\r\n  schema_json: any;\r\n}\r\n\r\ninterface SchemaMeta {\r\n  ts: number;\r\n  sha256: string;\r\n  size: number;\r\n}\r\n\r\ninterface PayloadValidateRequest {\r\n  variant: 'v0' | 'v1' | 'v2';\r\n  schema_ref?: string; // For V1: \"payload@v2\"\r\n  schema_inline?: any; // For V2: inline schema JSON\r\n  payload: any;\r\n  strict?: boolean;\r\n}\r\n\r\ninterface PayloadValidateResponse {\r\n  ok: boolean;\r\n  valid: boolean;\r\n  errors: string[];\r\n  policy_check?: {\r\n    decision: 'allow' | 'deny';\r\n    reason: string;\r\n    rule_id?: string;\r\n  };\r\n  ds_payload_ref?: string;\r\n  ds_payload_hash?: string;\r\n  cache_hit: boolean;\r\n  compile_ms: number;\r\n  validate_ms: number;\r\n  engine_ref: string;\r\n  evidence_refs: string[];\r\n}\r\n\r\n// Validator cache entry\r\ninterface CachedValidator {\r\n  validator: Validator;\r\n  timestamp: number;\r\n}\r\n\r\n// Global schema validator cache (per-request isolation in Workers)\r\n// In production, this would be per-isolate, but we'll use a module-level Map\r\nconst schemaCache = new Map<string, CachedValidator>();\r\n\r\n/**\r\n * Generate engine identity evidence\r\n */\r\nfunction generateEngineIdentity(request: Request, env: Env): Record<string, any> {\r\n  const cf = (request as any).cf || {};\r\n  return {\r\n    gateway_version: env.GATEWAY_VERSION,\r\n    cf_metadata: {\r\n      colo: cf.colo || 'unknown',\r\n      country: cf.country || 'unknown',\r\n      asn: cf.asn || 'unknown'\r\n    },\r\n    config: {\r\n      bindings: {\r\n        kv_namespaces: ['POLICY_KV'],\r\n        d1_databases: ['EPISODES_DB'],\r\n        r2_buckets: ['ARTIFACTS']\r\n      },\r\n      env: 'production' // Could be determined from request headers or env vars\r\n    },\r\n    timestamp: new Date().toISOString()\r\n  };\r\n}\r\n\r\n/**\r\n * Load policy from KV\r\n */\r\nasync function loadPolicy(policyRef: string, env: Env): Promise<PolicyProfile | null> {\r\n  // First, get active version\r\n  const versionKey = `policy:active:${policyRef}`;\r\n  const version = await env.POLICY_KV.get(versionKey);\r\n  \r\n  if (!version) {\r\n    return null;\r\n  }\r\n  \r\n  // Then, get policy profile\r\n  const policyKey = `policy:${policyRef}:${version}`;\r\n  const policyJson = await env.POLICY_KV.get(policyKey);\r\n  \r\n  if (!policyJson) {\r\n    return null;\r\n  }\r\n  \r\n  return JSON.parse(policyJson) as PolicyProfile;\r\n}\r\n\r\n/**\r\n * Check policy decision\r\n */\r\nfunction checkPolicy(\r\n  toolId: string,\r\n  args: Record<string, any>,\r\n  policy: PolicyProfile\r\n): { decision: 'allow' | 'deny'; reason: string; rule_id?: string } {\r\n  // Default deny\r\n  if (policy.default_decision === 'deny') {\r\n    // Check tool allowlist\r\n    if (policy.tool_allowlist && policy.tool_allowlist.includes(toolId)) {\r\n      // Additional check for http.fetch hostname allowlist\r\n      if (toolId === 'http.fetch' && args.url) {\r\n        try {\r\n          const url = new URL(args.url);\r\n          const hostname = url.hostname;\r\n          \r\n          if (policy.http_fetch_hostname_allowlist && \r\n              policy.http_fetch_hostname_allowlist.length > 0 &&\r\n              !policy.http_fetch_hostname_allowlist.includes(hostname)) {\r\n            return {\r\n              decision: 'deny',\r\n              reason: `Hostname ${hostname} not in allowlist`,\r\n              rule_id: 'http_fetch_hostname_check'\r\n            };\r\n          }\r\n        } catch (e) {\r\n          return {\r\n            decision: 'deny',\r\n            reason: `Invalid URL: ${e}`,\r\n            rule_id: 'http_fetch_url_validation'\r\n          };\r\n        }\r\n      }\r\n      \r\n      return {\r\n        decision: 'allow',\r\n        reason: `Tool ${toolId} is in allowlist`,\r\n        rule_id: 'tool_allowlist_match'\r\n      };\r\n    }\r\n    \r\n    return {\r\n      decision: 'deny',\r\n      reason: `Tool ${toolId} not in allowlist (default deny)`,\r\n      rule_id: 'default_deny'\r\n    };\r\n  }\r\n  \r\n  // Default allow (less common)\r\n  return {\r\n    decision: 'allow',\r\n    reason: 'Default allow policy',\r\n    rule_id: 'default_allow'\r\n  };\r\n}\r\n\r\n/**\r\n * Execute tool (v0: kv.get, http.fetch GET only)\r\n */\r\nasync function executeTool(\r\n  toolId: string,\r\n  args: Record<string, any>,\r\n  env: Env\r\n): Promise<ToolResult> {\r\n  if (toolId === 'kv.get') {\r\n    const key = args.key;\r\n    if (!key || typeof key !== 'string') {\r\n      return {\r\n        exit_code: 1,\r\n        stdout: '',\r\n        stderr: 'kv.get requires key (string)'\r\n      };\r\n    }\r\n    \r\n    try {\r\n      // KV.get returns null if key is missing (not an error)\r\n      const value = await env.POLICY_KV.get(key);\r\n      \r\n      // Missing key (null) is success with exit_code=0, data=null\r\n      // Only real errors (binding issues, exceptions) should return exit_code != 0\r\n      return {\r\n        exit_code: 0,\r\n        stdout: '',\r\n        stderr: '',\r\n        data: value // null if key not found, string if found\r\n      };\r\n    } catch (error: any) {\r\n      // Real execution error (binding issue, exception, etc.)\r\n      return {\r\n        exit_code: 1,\r\n        stdout: '',\r\n        stderr: `kv.get error: ${error.message || 'Unknown error'}`,\r\n        data: null\r\n      };\r\n    }\r\n  }\r\n  \r\n  if (toolId === 'http.fetch') {\r\n    const url = args.url;\r\n    if (!url || typeof url !== 'string') {\r\n      return {\r\n        exit_code: 1,\r\n        stdout: '',\r\n        stderr: 'http.fetch requires url (string)'\r\n      };\r\n    }\r\n    \r\n    // v0: GET only\r\n    const method = args.method || 'GET';\r\n    if (method !== 'GET') {\r\n      return {\r\n        exit_code: 1,\r\n        stdout: '',\r\n        stderr: 'http.fetch v0 supports GET only'\r\n      };\r\n    }\r\n    \r\n    try {\r\n      const response = await fetch(url, {\r\n        method: 'GET',\r\n        headers: args.headers || {}\r\n      });\r\n      \r\n      const text = await response.text();\r\n      \r\n      // Extract subset of headers\r\n      const headers: Record<string, string> = {};\r\n      const headerNames = ['content-type', 'content-length', 'cache-control'];\r\n      headerNames.forEach(name => {\r\n        const value = response.headers.get(name);\r\n        if (value) {\r\n          headers[name] = value;\r\n        }\r\n      });\r\n      \r\n      return {\r\n        exit_code: response.ok ? 0 : 1,\r\n        stdout: text,\r\n        stderr: response.ok ? '' : `HTTP ${response.status}`,\r\n        data: text,\r\n        status: response.status,\r\n        headers\r\n      };\r\n    } catch (error: any) {\r\n      return {\r\n        exit_code: 1,\r\n        stdout: '',\r\n        stderr: `Fetch error: ${error.message}`\r\n      };\r\n    }\r\n  }\r\n  \r\n  return {\r\n    exit_code: 1,\r\n    stdout: '',\r\n    stderr: `Unknown tool: ${toolId}`\r\n  };\r\n}\r\n\r\n/**\r\n * Compute SHA256 hash (using Web Crypto API)\r\n */\r\nasync function sha256(text: string): Promise<string> {\r\n  const encoder = new TextEncoder();\r\n  const data = encoder.encode(text);\r\n  const hashBuffer = await crypto.subtle.digest('SHA-256', data);\r\n  const hashArray = Array.from(new Uint8Array(hashBuffer));\r\n  return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');\r\n}\r\n\r\n/**\r\n * Load schema from KV by schema_ref (e.g., \"payload@v2\")\r\n */\r\nasync function loadSchema(schemaRef: string, env: Env): Promise<any | null> {\r\n  const [schemaId, version] = schemaRef.split('@');\r\n  if (!schemaId || !version) {\r\n    return null;\r\n  }\r\n  \r\n  const schemaKey = `schema:${schemaId}:${version}`;\r\n  const schemaJson = await env.POLICY_KV.get(schemaKey);\r\n  \r\n  if (!schemaJson) {\r\n    return null;\r\n  }\r\n  \r\n  return JSON.parse(schemaJson);\r\n}\r\n\r\n/**\r\n * Prepare schema validator (with caching)\r\n * Uses @cfworker/json-schema which is worker-safe (no code generation)\r\n */\r\nfunction prepareSchemaValidator(schemaJson: any, schemaHash: string): CachedValidator {\r\n  // Check cache\r\n  const cached = schemaCache.get(schemaHash);\r\n  if (cached) {\r\n    return cached;\r\n  }\r\n  \r\n  // Create new validator instance\r\n  // @cfworker/json-schema is worker-safe and doesn't use code generation\r\n  const validator = new Validator(schemaJson);\r\n  \r\n  const cachedValidator: CachedValidator = {\r\n    validator,\r\n    timestamp: Date.now()\r\n  };\r\n  \r\n  // Cache it (with size limit - simple LRU eviction)\r\n  if (schemaCache.size > 100) {\r\n    // Simple eviction: clear oldest 50%\r\n    const entries = Array.from(schemaCache.entries());\r\n    entries.sort((a, b) => a[1].timestamp - b[1].timestamp);\r\n    for (let i = 0; i < 50; i++) {\r\n      schemaCache.delete(entries[i][0]);\r\n    }\r\n  }\r\n  schemaCache.set(schemaHash, cachedValidator);\r\n  \r\n  return cachedValidator;\r\n}\r\n\r\n/**\r\n * Handle schema put request (admin only)\r\n */\r\nasync function handleSchemaPut(request: Request, env: Env): Promise<Response> {\r\n  try {\r\n    // Check admin auth\r\n    const authHeader = request.headers.get('Authorization');\r\n    if (!authHeader || !authHeader.startsWith('Bearer ')) {\r\n      return new Response(\r\n        JSON.stringify({ ok: false, error: 'Missing or invalid Authorization header' }),\r\n        { status: 401, headers: { 'Content-Type': 'application/json' } }\r\n      );\r\n    }\r\n    \r\n    const token = authHeader.substring(7);\r\n    const isAdmin = env.ADMIN_AUTH_TOKEN && token === env.ADMIN_AUTH_TOKEN;\r\n    if (!isAdmin && token !== env.GATEWAY_AUTH_TOKEN) {\r\n      return new Response(\r\n        JSON.stringify({ ok: false, error: 'Invalid auth token' }),\r\n        { status: 401, headers: { 'Content-Type': 'application/json' } }\r\n      );\r\n    }\r\n    \r\n    const body = await request.json() as SchemaPutRequest;\r\n    \r\n    // Validate schema_id and version\r\n    if (!body.schema_id || typeof body.schema_id !== 'string') {\r\n      return new Response(\r\n        JSON.stringify({ ok: false, error: 'schema_id required (string)' }),\r\n        { status: 400, headers: { 'Content-Type': 'application/json' } }\r\n      );\r\n    }\r\n    \r\n    if (!/^[a-zA-Z0-9._-]+$/.test(body.schema_id)) {\r\n      return new Response(\r\n        JSON.stringify({ ok: false, error: 'Invalid schema_id format' }),\r\n        { status: 400, headers: { 'Content-Type': 'application/json' } }\r\n      );\r\n    }\r\n    \r\n    if (!body.version || typeof body.version !== 'string') {\r\n      return new Response(\r\n        JSON.stringify({ ok: false, error: 'version required (string)' }),\r\n        { status: 400, headers: { 'Content-Type': 'application/json' } }\r\n      );\r\n    }\r\n    \r\n    if (!/^[a-zA-Z0-9._-]+$/.test(body.version)) {\r\n      return new Response(\r\n        JSON.stringify({ ok: false, error: 'Invalid version format' }),\r\n        { status: 400, headers: { 'Content-Type': 'application/json' } }\r\n      );\r\n    }\r\n    \r\n    if (body.schema_id.length > 128 || body.version.length > 64) {\r\n      return new Response(\r\n        JSON.stringify({ ok: false, error: 'schema_id or version too long' }),\r\n        { status: 400, headers: { 'Content-Type': 'application/json' } }\r\n      );\r\n    }\r\n    \r\n    // Validate schema_json\r\n    if (!body.schema_json || typeof body.schema_json !== 'object') {\r\n      return new Response(\r\n        JSON.stringify({ ok: false, error: 'schema_json required (object)' }),\r\n        { status: 400, headers: { 'Content-Type': 'application/json' } }\r\n      );\r\n    }\r\n    \r\n    const schemaJsonStr = JSON.stringify(body.schema_json);\r\n    const schemaSize = new TextEncoder().encode(schemaJsonStr).length;\r\n    \r\n    // Size limit: 64KB\r\n    if (schemaSize > 64 * 1024) {\r\n      return new Response(\r\n        JSON.stringify({ ok: false, error: 'schema_json too large (max 64KB)' }),\r\n        { status: 400, headers: { 'Content-Type': 'application/json' } }\r\n      );\r\n    }\r\n    \r\n    // Compute hash\r\n    const schemaHash = await sha256(schemaJsonStr);\r\n    \r\n    // Write to KV\r\n    const schemaKey = `schema:${body.schema_id}:${body.version}`;\r\n    await env.POLICY_KV.put(schemaKey, schemaJsonStr);\r\n    \r\n    // Write metadata\r\n    const metaKey = `schema:meta:${body.schema_id}:${body.version}`;\r\n    const meta: SchemaMeta = {\r\n      ts: Date.now(),\r\n      sha256: schemaHash,\r\n      size: schemaSize\r\n    };\r\n    await env.POLICY_KV.put(metaKey, JSON.stringify(meta));\r\n    \r\n    // Update active version (optional, but useful)\r\n    const activeKey = `schema:active:${body.schema_id}`;\r\n    await env.POLICY_KV.put(activeKey, body.version);\r\n    \r\n    return new Response(\r\n      JSON.stringify({\r\n        ok: true,\r\n        schema_ref: `${body.schema_id}@${body.version}`,\r\n        schema_hash: schemaHash\r\n      }),\r\n      { headers: { 'Content-Type': 'application/json' } }\r\n    );\r\n  } catch (error: any) {\r\n    return new Response(\r\n      JSON.stringify({ ok: false, error: error.message }),\r\n      { status: 500, headers: { 'Content-Type': 'application/json' } }\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * Handle schema get request\r\n */\r\nasync function handleSchemaGet(request: Request, env: Env): Promise<Response> {\r\n  try {\r\n    // Check auth\r\n    const authHeader = request.headers.get('Authorization');\r\n    if (!authHeader || !authHeader.startsWith('Bearer ')) {\r\n      return new Response(\r\n        JSON.stringify({ ok: false, error: 'Missing or invalid Authorization header' }),\r\n        { status: 401, headers: { 'Content-Type': 'application/json' } }\r\n      );\r\n    }\r\n    \r\n    const token = authHeader.substring(7);\r\n    if (token !== env.GATEWAY_AUTH_TOKEN && token !== env.ADMIN_AUTH_TOKEN) {\r\n      return new Response(\r\n        JSON.stringify({ ok: false, error: 'Invalid auth token' }),\r\n        { status: 401, headers: { 'Content-Type': 'application/json' } }\r\n      );\r\n    }\r\n    \r\n    const url = new URL(request.url);\r\n    const schemaId = url.searchParams.get('schema_id');\r\n    const version = url.searchParams.get('version');\r\n    \r\n    if (!schemaId || !version) {\r\n      return new Response(\r\n        JSON.stringify({ ok: false, error: 'Missing schema_id or version parameter' }),\r\n        { status: 400, headers: { 'Content-Type': 'application/json' } }\r\n      );\r\n    }\r\n    \r\n    const schemaKey = `schema:${schemaId}:${version}`;\r\n    const schemaJson = await env.POLICY_KV.get(schemaKey);\r\n    \r\n    if (!schemaJson) {\r\n      return new Response(\r\n        JSON.stringify({ ok: false, error: 'Schema not found' }),\r\n        { status: 404, headers: { 'Content-Type': 'application/json' } }\r\n      );\r\n    }\r\n    \r\n    return new Response(schemaJson, {\r\n      headers: { 'Content-Type': 'application/json' }\r\n    });\r\n  } catch (error: any) {\r\n    return new Response(\r\n      JSON.stringify({ ok: false, error: error.message }),\r\n      { status: 500, headers: { 'Content-Type': 'application/json' } }\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * Write payload validate episode to D1\r\n */\r\nasync function writePayloadValidateEpisode(\r\n  requestId: string,\r\n  runId: string,\r\n  stepId: string,\r\n  engineRef: string,\r\n  variant: string,\r\n  dsPayloadRef: string | undefined,\r\n  dsPayloadHash: string | undefined,\r\n  cacheHit: boolean,\r\n  compileMs: number,\r\n  validateMs: number,\r\n  valid: boolean,\r\n  errors: string[],\r\n  evidenceRefs: string[],\r\n  payload: any,\r\n  env: Env\r\n): Promise<void> {\r\n  const ts = Date.now();\r\n  const type = 'payload_validate';\r\n  \r\n  // Extend payload with experiment-specific fields\r\n  const episodePayload = {\r\n    ...payload,\r\n    variant,\r\n    ds_payload_ref: dsPayloadRef,\r\n    ds_payload_hash: dsPayloadHash,\r\n    cache_hit: cacheHit,\r\n    compile_ms: compileMs,\r\n    validate_ms: validateMs,\r\n    valid,\r\n    errors\r\n  };\r\n  \r\n  await env.EPISODES_DB.prepare(`\r\n    INSERT INTO episodes (\r\n      id, ts, type, run_id, step_id, policy_ref, policy_version,\r\n      engine_ref, decision, reason, evidence_refs_json, payload_json\r\n    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\r\n  `).bind(\r\n    requestId,\r\n    ts,\r\n    type,\r\n    runId,\r\n    stepId,\r\n    'schema_payload_experiment',\r\n    'v1',\r\n    engineRef,\r\n    valid ? 'allow' : 'deny',\r\n    valid ? 'Payload valid' : `Payload invalid: ${errors.join('; ')}`,\r\n    JSON.stringify(evidenceRefs),\r\n    JSON.stringify(episodePayload)\r\n  ).run();\r\n}\r\n\r\n/**\r\n * Handle payload validate request\r\n */\r\nasync function handlePayloadValidate(request: Request, env: Env): Promise<Response> {\r\n  const startTime = Date.now();\r\n  let requestId = `payload_validate_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\r\n  \r\n  try {\r\n    // Check auth\r\n    const authHeader = request.headers.get('Authorization');\r\n    if (!authHeader || !authHeader.startsWith('Bearer ')) {\r\n      return new Response(\r\n        JSON.stringify({ ok: false, error: 'Missing or invalid Authorization header' }),\r\n        { status: 401, headers: { 'Content-Type': 'application/json' } }\r\n      );\r\n    }\r\n    \r\n    const token = authHeader.substring(7);\r\n    const isAdmin = env.ADMIN_AUTH_TOKEN && token === env.ADMIN_AUTH_TOKEN;\r\n    const isRegular = token === env.GATEWAY_AUTH_TOKEN;\r\n    \r\n    if (!isAdmin && !isRegular) {\r\n      return new Response(\r\n        JSON.stringify({ ok: false, error: 'Invalid auth token' }),\r\n        { status: 401, headers: { 'Content-Type': 'application/json' } }\r\n      );\r\n    }\r\n    \r\n    const body = await request.json() as PayloadValidateRequest;\r\n    \r\n    // Generate engine identity\r\n    const engineIdentity = generateEngineIdentity(request, env);\r\n    const engineRef = `${env.GATEWAY_VERSION}@${(request as any).cf?.colo || 'unknown'}`;\r\n    \r\n    // Prepare evidence refs\r\n    const evidenceRefs: string[] = [];\r\n    const runId = `run_${requestId}`;\r\n    const stepId = `step_${requestId}`;\r\n    \r\n    // Write request artifact\r\n    const requestKey = `payload_validate/${requestId}/request.json`;\r\n    await env.ARTIFACTS.put(requestKey, JSON.stringify(body, null, 2));\r\n    evidenceRefs.push(requestKey);\r\n    \r\n    // Write engine identity\r\n    const identityKey = `payload_validate/${requestId}/engine_identity.json`;\r\n    await env.ARTIFACTS.put(identityKey, JSON.stringify(engineIdentity, null, 2));\r\n    evidenceRefs.push(identityKey);\r\n    \r\n    let schemaJson: any = null;\r\n    let schemaHash: string = '';\r\n    let dsPayloadRef: string | undefined = undefined;\r\n    let cacheHit = false;\r\n    let compileMs = 0;\r\n    let validateMs = 0;\r\n    let valid = false;\r\n    let errors: string[] = [];\r\n    \r\n    // V0: Hardcoded schema\r\n    if (body.variant === 'v0') {\r\n      // Load hardcoded ds.payload_v1 schema\r\n      // For simplicity, we'll embed a minimal version here\r\n      schemaJson = {\r\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\r\n        \"type\": \"object\",\r\n        \"required\": [\"kind\", \"data\"],\r\n        \"properties\": {\r\n          \"kind\": { \"type\": \"string\" },\r\n          \"data\": { \"type\": \"object\", \"additionalProperties\": true },\r\n          \"meta\": { \"type\": \"object\", \"additionalProperties\": true }\r\n        }\r\n      };\r\n      const schemaJsonStr = JSON.stringify(schemaJson);\r\n      schemaHash = await sha256(schemaJsonStr);\r\n      dsPayloadRef = 'payload@v1';\r\n    }\r\n    // V1: Schema from registry\r\n    else if (body.variant === 'v1') {\r\n      if (!body.schema_ref) {\r\n        return new Response(\r\n          JSON.stringify({ ok: false, error: 'schema_ref required for variant v1' }),\r\n          { status: 400, headers: { 'Content-Type': 'application/json' } }\r\n        );\r\n      }\r\n      \r\n      schemaJson = await loadSchema(body.schema_ref, env);\r\n      if (!schemaJson) {\r\n        return new Response(\r\n          JSON.stringify({ ok: false, error: `Schema ${body.schema_ref} not found` }),\r\n          { status: 404, headers: { 'Content-Type': 'application/json' } }\r\n        );\r\n      }\r\n      \r\n      const schemaJsonStr = JSON.stringify(schemaJson);\r\n      schemaHash = await sha256(schemaJsonStr);\r\n      dsPayloadRef = body.schema_ref;\r\n    }\r\n    // V2: Inline schema (dangerous - requires admin or ALLOW_INLINE_SCHEMA)\r\n    else if (body.variant === 'v2') {\r\n      // Check policy: deny by default\r\n      const allowInline = env.ALLOW_INLINE_SCHEMA === 'true' || isAdmin;\r\n      if (!allowInline) {\r\n        // Policy check: deny V2 inline schema\r\n        const policyCheck = {\r\n          decision: 'deny' as const,\r\n          reason: 'V2 inline schema not allowed (deny-by-default)',\r\n          rule_id: 'v2_inline_schema_deny'\r\n        };\r\n        \r\n        // Write deny episode\r\n        const denyKey = `payload_validate/${requestId}/policy_deny.json`;\r\n        await env.ARTIFACTS.put(denyKey, JSON.stringify(policyCheck, null, 2));\r\n        evidenceRefs.push(denyKey);\r\n        \r\n        await writePayloadValidateEpisode(\r\n          requestId,\r\n          runId,\r\n          stepId,\r\n          engineRef,\r\n          'v2',\r\n          undefined,\r\n          undefined,\r\n          false,\r\n          0,\r\n          0,\r\n          false,\r\n          [policyCheck.reason],\r\n          evidenceRefs,\r\n          { request: body, policy_check: policyCheck },\r\n          env\r\n        );\r\n        \r\n        return new Response(\r\n          JSON.stringify({\r\n            ok: true,\r\n            valid: false,\r\n            errors: [policyCheck.reason],\r\n            policy_check: policyCheck,\r\n            cache_hit: false,\r\n            compile_ms: 0,\r\n            validate_ms: 0,\r\n            engine_ref: engineRef,\r\n            evidence_refs: evidenceRefs\r\n          } as PayloadValidateResponse),\r\n          { status: 403, headers: { 'Content-Type': 'application/json' } }\r\n        );\r\n      }\r\n      \r\n      if (!body.schema_inline) {\r\n        return new Response(\r\n          JSON.stringify({ ok: false, error: 'schema_inline required for variant v2' }),\r\n          { status: 400, headers: { 'Content-Type': 'application/json' } }\r\n        );\r\n      }\r\n      \r\n      schemaJson = body.schema_inline;\r\n      const schemaJsonStr = JSON.stringify(schemaJson);\r\n      schemaHash = await sha256(schemaJsonStr);\r\n      dsPayloadRef = 'inline@v2';\r\n    }\r\n    else {\r\n      return new Response(\r\n        JSON.stringify({ ok: false, error: 'Invalid variant (must be v0, v1, or v2)' }),\r\n        { status: 400, headers: { 'Content-Type': 'application/json' } }\r\n      );\r\n    }\r\n    \r\n    // Compute payload hash\r\n    const payloadJsonStr = JSON.stringify(body.payload);\r\n    const payloadHash = await sha256(payloadJsonStr);\r\n    \r\n    // Prepare schema validator (with caching)\r\n    const compileStart = Date.now();\r\n    const cached = schemaCache.get(schemaHash);\r\n    let cachedValidator: CachedValidator;\r\n    \r\n    if (cached) {\r\n      cacheHit = true;\r\n      cachedValidator = cached;\r\n      compileMs = 0;\r\n    } else {\r\n      cacheHit = false;\r\n      cachedValidator = prepareSchemaValidator(schemaJson, schemaHash);\r\n      compileMs = Date.now() - compileStart;\r\n    }\r\n    \r\n    // Validate payload\r\n    const validateStart = Date.now();\r\n    const validationResult = cachedValidator.validator.validate(body.payload);\r\n    validateMs = Date.now() - validateStart;\r\n    \r\n    valid = validationResult.valid;\r\n    \r\n    if (!valid && validationResult.errors) {\r\n      errors = validationResult.errors.map((e: any) => {\r\n        // @cfworker/json-schema error format: { instanceLocation, error, keyword, keywordLocation }\r\n        const path = e.instanceLocation || '/';\r\n        const message = e.error || 'Validation error';\r\n        return `${path}: ${message}`;\r\n      });\r\n    }\r\n    \r\n    // Write validation result\r\n    const resultKey = `payload_validate/${requestId}/validate_result.json`;\r\n    const validateResultData = {\r\n      valid,\r\n      errors,\r\n      ds_payload_ref: dsPayloadRef,\r\n      ds_payload_hash: payloadHash,\r\n      cache_hit: cacheHit,\r\n      compile_ms: compileMs,\r\n      validate_ms: validateMs\r\n    };\r\n    await env.ARTIFACTS.put(resultKey, JSON.stringify(validateResultData, null, 2));\r\n    evidenceRefs.push(resultKey);\r\n    \r\n    // Write response\r\n    const responseKey = `payload_validate/${requestId}/response.json`;\r\n    const response: PayloadValidateResponse = {\r\n      ok: true,\r\n      valid,\r\n      errors,\r\n      // Add policy_check for successful validations (allow)\r\n      policy_check: valid ? {\r\n        decision: 'allow' as const,\r\n        reason: 'Payload valid',\r\n        rule_id: 'payload_validation_pass'\r\n      } : undefined,\r\n      ds_payload_ref: dsPayloadRef,\r\n      ds_payload_hash: payloadHash,\r\n      cache_hit: cacheHit,\r\n      compile_ms: compileMs,\r\n      validate_ms: validateMs,\r\n      engine_ref: engineRef,\r\n      evidence_refs: evidenceRefs\r\n    };\r\n    await env.ARTIFACTS.put(responseKey, JSON.stringify(response, null, 2));\r\n    evidenceRefs.push(responseKey);\r\n    \r\n    // Write episode\r\n    await writePayloadValidateEpisode(\r\n      requestId,\r\n      runId,\r\n      stepId,\r\n      engineRef,\r\n      body.variant,\r\n      dsPayloadRef,\r\n      payloadHash,\r\n      cacheHit,\r\n      compileMs,\r\n      validateMs,\r\n      valid,\r\n      errors,\r\n      evidenceRefs,\r\n      { request: body, validate_result: validateResultData },\r\n      env\r\n    );\r\n    \r\n    return new Response(\r\n      JSON.stringify(response, null, 2),\r\n      { headers: { 'Content-Type': 'application/json' } }\r\n    );\r\n  } catch (error: any) {\r\n    return new Response(\r\n      JSON.stringify({ ok: false, error: error.message }),\r\n      { status: 500, headers: { 'Content-Type': 'application/json' } }\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * Write episode to D1\r\n */\r\nasync function writeEpisode(\r\n  requestId: string,\r\n  runId: string,\r\n  stepId: string,\r\n  policyRef: string,\r\n  policyVersion: string,\r\n  engineRef: string,\r\n  decision: 'allow' | 'deny',\r\n  reason: string,\r\n  evidenceRefs: string[],\r\n  payload: any,\r\n  env: Env\r\n): Promise<void> {\r\n  const ts = Date.now();\r\n  const type = decision === 'allow' ? 'tool_execution' : 'policy_deny';\r\n  \r\n  await env.EPISODES_DB.prepare(`\r\n    INSERT INTO episodes (\r\n      id, ts, type, run_id, step_id, policy_ref, policy_version,\r\n      engine_ref, decision, reason, evidence_refs_json, payload_json\r\n    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\r\n  `).bind(\r\n    requestId,\r\n    ts,\r\n    type,\r\n    runId,\r\n    stepId,\r\n    policyRef,\r\n    policyVersion,\r\n    engineRef,\r\n    decision,\r\n    reason,\r\n    JSON.stringify(evidenceRefs),\r\n    JSON.stringify(payload)\r\n  ).run();\r\n}\r\n\r\n/**\r\n * Handle episode search request\r\n */\r\nasync function handleEpisodeSearch(request: Request, env: Env): Promise<Response> {\r\n  try {\r\n    const body = await request.json() as {\r\n      limit?: number;\r\n      id?: string;\r\n      id_prefix?: string;\r\n      decision?: 'allow' | 'deny';\r\n      type?: 'tool_execution' | 'policy_deny';\r\n      since_ts?: number;\r\n      until_ts?: number;\r\n      order?: 'desc' | 'asc';\r\n    };\r\n    \r\n    // Validate and set defaults\r\n    const limit = Math.min(Math.max(body.limit || 20, 1), 100);\r\n    const order = body.order || 'desc';\r\n    const orderClause = order === 'asc' ? 'ASC' : 'DESC';\r\n    \r\n    // Build query with bound parameters\r\n    let query = 'SELECT id, ts, type, run_id, step_id, policy_ref, policy_version, engine_ref, decision, reason, evidence_refs_json FROM episodes WHERE 1=1';\r\n    const bindings: any[] = [];\r\n    \r\n    if (body.id) {\r\n      query += ' AND id = ?';\r\n      bindings.push(body.id);\r\n    }\r\n    \r\n    if (body.id_prefix) {\r\n      query += ' AND id LIKE ?';\r\n      bindings.push(`${body.id_prefix}%`);\r\n    }\r\n    \r\n    if (body.decision) {\r\n      query += ' AND decision = ?';\r\n      bindings.push(body.decision);\r\n    }\r\n    \r\n    if (body.type) {\r\n      query += ' AND type = ?';\r\n      bindings.push(body.type);\r\n    }\r\n    \r\n    if (body.since_ts) {\r\n      query += ' AND ts >= ?';\r\n      bindings.push(body.since_ts);\r\n    }\r\n    \r\n    if (body.until_ts) {\r\n      query += ' AND ts <= ?';\r\n      bindings.push(body.until_ts);\r\n    }\r\n    \r\n    query += ` ORDER BY ts ${orderClause} LIMIT ?`;\r\n    bindings.push(limit);\r\n    \r\n    // Execute query with bound parameters (bind all at once)\r\n    const stmt = env.EPISODES_DB.prepare(query);\r\n    const result = await stmt.bind(...bindings).all();\r\n    \r\n    // Transform results\r\n    const results = (result.results || []).map((row: any) => {\r\n      let evidenceRefs: string[] = [];\r\n      try {\r\n        evidenceRefs = JSON.parse(row.evidence_refs_json || '[]');\r\n      } catch (e) {\r\n        evidenceRefs = [];\r\n      }\r\n      \r\n      return {\r\n        id: row.id,\r\n        ts: row.ts,\r\n        type: row.type,\r\n        run_id: row.run_id,\r\n        step_id: row.step_id,\r\n        policy_ref: row.policy_ref,\r\n        policy_version: row.policy_version,\r\n        engine_ref: row.engine_ref,\r\n        decision: row.decision,\r\n        reason: row.reason,\r\n        evidence_refs: evidenceRefs\r\n      };\r\n    });\r\n    \r\n    return new Response(\r\n      JSON.stringify({ ok: true, results }),\r\n      { headers: { 'Content-Type': 'application/json' } }\r\n    );\r\n  } catch (error: any) {\r\n    return new Response(\r\n      JSON.stringify({ ok: false, error: error.message }),\r\n      { status: 400, headers: { 'Content-Type': 'application/json' } }\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * Handle artifact get request\r\n */\r\nasync function handleArtifactGet(request: Request, env: Env): Promise<Response> {\r\n  try {\r\n    const url = new URL(request.url);\r\n    const ref = url.searchParams.get('ref');\r\n    \r\n    if (!ref) {\r\n      return new Response(\r\n        JSON.stringify({ ok: false, error: 'Missing ref parameter' }),\r\n        { status: 400, headers: { 'Content-Type': 'application/json' } }\r\n      );\r\n    }\r\n    \r\n    // Validate ref\r\n    if (ref.length > 512) {\r\n      return new Response(\r\n        JSON.stringify({ ok: false, error: 'ref too long (max 512)' }),\r\n        { status: 400, headers: { 'Content-Type': 'application/json' } }\r\n      );\r\n    }\r\n    \r\n    if (!/^[a-zA-Z0-9._/-]+$/.test(ref)) {\r\n      return new Response(\r\n        JSON.stringify({ ok: false, error: 'Invalid ref format' }),\r\n        { status: 400, headers: { 'Content-Type': 'application/json' } }\r\n      );\r\n    }\r\n    \r\n    if (ref.includes('..')) {\r\n      return new Response(\r\n        JSON.stringify({ ok: false, error: 'ref must not contain ..' }),\r\n        { status: 400, headers: { 'Content-Type': 'application/json' } }\r\n      );\r\n    }\r\n    \r\n    if (ref.startsWith('/')) {\r\n      return new Response(\r\n        JSON.stringify({ ok: false, error: 'ref must not start with /' }),\r\n        { status: 400, headers: { 'Content-Type': 'application/json' } }\r\n      );\r\n    }\r\n    \r\n    // Get from R2\r\n    const object = await env.ARTIFACTS.get(ref);\r\n    \r\n    if (!object) {\r\n      return new Response(\r\n        JSON.stringify({ ok: false, error: 'Artifact not found' }),\r\n        { status: 404, headers: { 'Content-Type': 'application/json' } }\r\n      );\r\n    }\r\n    \r\n    // Determine content type\r\n    let contentType = 'application/octet-stream';\r\n    if (ref.endsWith('.json')) {\r\n      contentType = 'application/json';\r\n    } else if (ref.endsWith('.jsonl')) {\r\n      contentType = 'application/x-ndjson';\r\n    }\r\n    \r\n    // Get body\r\n    const body = await object.arrayBuffer();\r\n    \r\n    return new Response(body, {\r\n      headers: {\r\n        'Content-Type': contentType,\r\n        'Cache-Control': 'no-store'\r\n      }\r\n    });\r\n  } catch (error: any) {\r\n    return new Response(\r\n      JSON.stringify({ ok: false, error: error.message }),\r\n      { status: 500, headers: { 'Content-Type': 'application/json' } }\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * Handle tool execution request\r\n */\r\nasync function handleToolRun(request: Request, env: Env): Promise<Response> {\r\n  // Parse request\r\n  const body = await request.json() as ToolRequest;\r\n  \r\n  // Validate required fields\r\n  const requestId = body.request_id || body.envelope_id || `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\r\n  const toolId = body.tool_id;\r\n  const args = body.args || {};\r\n  const ctx = body.ctx || {};\r\n  \r\n  if (!toolId) {\r\n    return new Response(\r\n      JSON.stringify({ ok: false, error: 'tool_id required' }),\r\n      { status: 400, headers: { 'Content-Type': 'application/json' } }\r\n    );\r\n  }\r\n  \r\n  // Derive deterministic IDs\r\n  const runId = ctx.run_id || `run_${requestId}`;\r\n  const stepId = ctx.step_id || `step_${requestId}`;\r\n  const policyRef = ctx.policy_ref || env.DEFAULT_POLICY_REF;\r\n  \r\n  // Load policy\r\n  const policy = await loadPolicy(policyRef, env);\r\n  \r\n  if (!policy) {\r\n    return new Response(\r\n      JSON.stringify({ ok: false, error: `Policy ${policyRef} not found` }),\r\n      { status: 404, headers: { 'Content-Type': 'application/json' } }\r\n    );\r\n  }\r\n  \r\n  // Check policy\r\n  const policyCheck = checkPolicy(toolId, args, policy);\r\n  \r\n  // Generate engine identity\r\n  const engineIdentity = generateEngineIdentity(request, env);\r\n  const engineRef = `${env.GATEWAY_VERSION}@${(request as any).cf?.colo || 'unknown'}`;\r\n  \r\n  // Prepare evidence refs\r\n  const evidenceRefs: string[] = [];\r\n  const timestamp = Date.now();\r\n  \r\n  // Write request artifact\r\n  const requestKey = `requests/${requestId}/request.json`;\r\n  await env.ARTIFACTS.put(requestKey, JSON.stringify(body, null, 2));\r\n  evidenceRefs.push(requestKey);\r\n  \r\n  // Write engine identity\r\n  const identityKey = `requests/${requestId}/engine_identity.json`;\r\n  await env.ARTIFACTS.put(identityKey, JSON.stringify(engineIdentity, null, 2));\r\n  evidenceRefs.push(identityKey);\r\n  \r\n  if (policyCheck.decision === 'deny') {\r\n    // DENY path: write policy decision, no side effects\r\n    const decisionKey = `requests/${requestId}/policy_decision.json`;\r\n    await env.ARTIFACTS.put(decisionKey, JSON.stringify(policyCheck, null, 2));\r\n    evidenceRefs.push(decisionKey);\r\n    \r\n    // Write episode\r\n    await writeEpisode(\r\n      requestId,\r\n      runId,\r\n      stepId,\r\n      policyRef,\r\n      policy.policy_version,\r\n      engineRef,\r\n      'deny',\r\n      policyCheck.reason,\r\n      evidenceRefs,\r\n      { request: body, policy_check: policyCheck },\r\n      env\r\n    );\r\n    \r\n    const response: GatewayResponse = {\r\n      ok: false,\r\n      policy_check: policyCheck,\r\n      evidence_refs: evidenceRefs,\r\n      engine_ref: engineRef\r\n    };\r\n    \r\n    return new Response(\r\n      JSON.stringify(response, null, 2),\r\n      { status: 403, headers: { 'Content-Type': 'application/json' } }\r\n    );\r\n  }\r\n  \r\n  // ALLOW path: execute tool\r\n  const toolResult = await executeTool(toolId, args, env);\r\n  \r\n  // Write tool result\r\n  const resultKey = `requests/${requestId}/tool_result.json`;\r\n  await env.ARTIFACTS.put(resultKey, JSON.stringify(toolResult, null, 2));\r\n  evidenceRefs.push(resultKey);\r\n  \r\n  // Write response\r\n  const responseKey = `requests/${requestId}/response.json`;\r\n  const gatewayResponse: GatewayResponse = {\r\n    ok: true,\r\n    tool_result: toolResult,\r\n    policy_check: policyCheck,\r\n    evidence_refs: evidenceRefs,\r\n    engine_ref: engineRef\r\n  };\r\n  await env.ARTIFACTS.put(responseKey, JSON.stringify(gatewayResponse, null, 2));\r\n  evidenceRefs.push(responseKey);\r\n  \r\n  // Write episode\r\n  await writeEpisode(\r\n    requestId,\r\n    runId,\r\n    stepId,\r\n    policyRef,\r\n    policy.policy_version,\r\n    engineRef,\r\n    'allow',\r\n    policyCheck.reason,\r\n    evidenceRefs,\r\n    { request: body, tool_result: toolResult, policy_check: policyCheck },\r\n    env\r\n  );\r\n  \r\n  return new Response(\r\n    JSON.stringify(gatewayResponse, null, 2),\r\n    { status: 200, headers: { 'Content-Type': 'application/json' } }\r\n  );\r\n}\r\n\r\n/**\r\n * Main fetch handler\r\n */\r\nexport default {\r\n  async fetch(request: Request, env: Env, ctx: any): Promise<Response> {\r\n    const url = new URL(request.url);\r\n    \r\n    // Health check\r\n    if (url.pathname === '/health' && request.method === 'GET') {\r\n      const cf = (request as any).cf || {};\r\n      return new Response(\r\n        JSON.stringify({\r\n          ok: true,\r\n          engine_ref: `${env.GATEWAY_VERSION}@${cf.colo || 'unknown'}`,\r\n          time: new Date().toISOString()\r\n        }),\r\n        { headers: { 'Content-Type': 'application/json' } }\r\n      );\r\n    }\r\n    \r\n    // Tool execution\r\n    if (url.pathname === '/tool/run' && request.method === 'POST') {\r\n      // Check auth\r\n      const authHeader = request.headers.get('Authorization');\r\n      if (!authHeader || !authHeader.startsWith('Bearer ')) {\r\n        return new Response(\r\n          JSON.stringify({ ok: false, error: 'Missing or invalid Authorization header' }),\r\n          { status: 401, headers: { 'Content-Type': 'application/json' } }\r\n        );\r\n      }\r\n      \r\n      const token = authHeader.substring(7);\r\n      if (token !== env.GATEWAY_AUTH_TOKEN) {\r\n        return new Response(\r\n          JSON.stringify({ ok: false, error: 'Invalid auth token' }),\r\n          { status: 401, headers: { 'Content-Type': 'application/json' } }\r\n        );\r\n      }\r\n      \r\n      return handleToolRun(request, env);\r\n    }\r\n    \r\n    // Episode search\r\n    if (url.pathname === '/episode/search' && request.method === 'POST') {\r\n      // Check auth\r\n      const authHeader = request.headers.get('Authorization');\r\n      if (!authHeader || !authHeader.startsWith('Bearer ')) {\r\n        return new Response(\r\n          JSON.stringify({ ok: false, error: 'Missing or invalid Authorization header' }),\r\n          { status: 401, headers: { 'Content-Type': 'application/json' } }\r\n        );\r\n      }\r\n      \r\n      const token = authHeader.substring(7);\r\n      if (token !== env.GATEWAY_AUTH_TOKEN) {\r\n        return new Response(\r\n          JSON.stringify({ ok: false, error: 'Invalid auth token' }),\r\n          { status: 401, headers: { 'Content-Type': 'application/json' } }\r\n        );\r\n      }\r\n      \r\n      return handleEpisodeSearch(request, env);\r\n    }\r\n    \r\n    // Artifact get\r\n    if (url.pathname === '/artifact/get' && request.method === 'GET') {\r\n      // Check auth\r\n      const authHeader = request.headers.get('Authorization');\r\n      if (!authHeader || !authHeader.startsWith('Bearer ')) {\r\n        return new Response(\r\n          JSON.stringify({ ok: false, error: 'Missing or invalid Authorization header' }),\r\n          { status: 401, headers: { 'Content-Type': 'application/json' } }\r\n        );\r\n      }\r\n      \r\n      const token = authHeader.substring(7);\r\n      if (token !== env.GATEWAY_AUTH_TOKEN) {\r\n        return new Response(\r\n          JSON.stringify({ ok: false, error: 'Invalid auth token' }),\r\n          { status: 401, headers: { 'Content-Type': 'application/json' } }\r\n        );\r\n      }\r\n      \r\n      return handleArtifactGet(request, env);\r\n    }\r\n    \r\n    // Schema put (admin only)\r\n    if (url.pathname === '/schema/put' && request.method === 'POST') {\r\n      return handleSchemaPut(request, env);\r\n    }\r\n    \r\n    // Schema get\r\n    if (url.pathname === '/schema/get' && request.method === 'GET') {\r\n      return handleSchemaGet(request, env);\r\n    }\r\n    \r\n    // Payload validate\r\n    if (url.pathname === '/payload/validate' && request.method === 'POST') {\r\n      return handlePayloadValidate(request, env);\r\n    }\r\n    \r\n    // 404 for unknown routes\r\n    return new Response(\r\n      JSON.stringify({ ok: false, error: 'Not found' }),\r\n      { status: 404, headers: { 'Content-Type': 'application/json' } }\r\n    );\r\n  }\r\n};\r\n\r\n"],
  "mappings": "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",
  "names": ["uri", "regex", "keywordLocation"]
}
