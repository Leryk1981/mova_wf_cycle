{
  "case_id": "runtime_binding_scaffolder_case_01",
  "description": "Example case for skill.runtime_binding_code_scaffolder_basic: generating Node.js code for FakeTasks connector.",
  "envelope": {
    "envelope_id": "env.runtime_binding_scaffold_run_v1",
    "verb": "transform",
    "resource": "runtime_binding",
    "input": {
      "skill_id": "skill.connectors.fake_tasks_v1",
      "skill_dir": "connectors_fake_tasks",
      "runtime_kind": "node_script",
      "language": "ts",
      "code_entry_path": "src/skills/connectors_fake_tasks/index.ts",
      "envelopes": [
        {
          "envelope_id": "env.fake_tasks_create_run_v1",
          "summary": "Create a new task with title, description, and optional due date",
          "input_hint": "Task object with title, description, optional due_date",
          "output_hint": "Created task object with id, title, description, status, created_at"
        },
        {
          "envelope_id": "env.fake_tasks_list_run_v1",
          "summary": "List all tasks with optional filtering by status",
          "input_hint": "Optional filters: status, page, limit",
          "output_hint": "Array of task objects with pagination metadata"
        },
        {
          "envelope_id": "env.fake_tasks_update_run_v1",
          "summary": "Update an existing task by ID",
          "input_hint": "Task id and partial update object (title, description, status, etc.)",
          "output_hint": "Updated task object"
        }
      ],
      "binding_stub": {
        "binding_id": "fake_tasks_http_binding_v1",
        "skill_id": "skill.connectors.fake_tasks_v1",
        "runtime_type": "other",
        "entrypoint": {
          "base_url": "https://api.fake-tasks.test",
          "auth_type": "bearer_token",
          "auth_header": "Authorization",
          "endpoints": {
            "create_task": {
              "method": "POST",
              "path": "/api/v1/tasks"
            },
            "list_tasks": {
              "method": "GET",
              "path": "/api/v1/tasks"
            },
            "update_task": {
              "method": "PATCH",
              "path": "/api/v1/tasks/{task_id}"
            }
          }
        }
      },
      "notes_for_code": "Use async/await + fetch. Wrap errors into custom Error classes. Do not log secrets. Handle rate limits gracefully."
    },
    "meta": {
      "language": "en"
    }
  },
  "expected_output": {
    "skill_id": "skill.connectors.fake_tasks_v1",
    "skill_dir": "connectors_fake_tasks",
    "code_entry_path": "src/skills/connectors_fake_tasks/index.ts",
    "files": [
      {
        "relative_path": "src/skills/connectors_fake_tasks/index.ts",
        "kind": "runtime_code",
        "content": "// Runtime binding for skill.connectors.fake_tasks_v1\n// Generated by skill.runtime_binding_code_scaffolder_basic\n\nconst API_BASE_URL = process.env.FAKETASKS_API_URL || 'https://api.fake-tasks.test';\nconst API_TOKEN = process.env.FAKETASKS_API_TOKEN;\n\nif (!API_TOKEN) {\n  throw new Error('FAKETASKS_API_TOKEN environment variable is required');\n}\n\nasync function makeRequest(method: string, path: string, body?: any): Promise<any> {\n  const url = `${API_BASE_URL}${path}`;\n  const headers: Record<string, string> = {\n    'Authorization': `Bearer ${API_TOKEN}`,\n    'Content-Type': 'application/json'\n  };\n\n  try {\n    const response = await fetch(url, {\n      method,\n      headers,\n      body: body ? JSON.stringify(body) : undefined\n    });\n\n    if (!response.ok) {\n      // TODO: Implement proper error handling\n      throw new Error(`API request failed: ${response.status} ${response.statusText}`);\n    }\n\n    return await response.json();\n  } catch (error) {\n    // TODO: Wrap in custom Error class\n    throw error;\n  }\n}\n\n/**\n * Execute env.fake_tasks_create_run_v1\n * Create a new task with title, description, and optional due date\n */\nexport async function runFakeTasksCreate(input: any): Promise<any> {\n  const { title, description, due_date } = input;\n  return await makeRequest('POST', '/api/v1/tasks', {\n    title,\n    description,\n    due_date\n  });\n}\n\n/**\n * Execute env.fake_tasks_list_run_v1\n * List all tasks with optional filtering by status\n */\nexport async function runFakeTasksList(input: any): Promise<any> {\n  const { status, page, limit } = input || {};\n  const params = new URLSearchParams();\n  if (status) params.append('status', status);\n  if (page) params.append('page', String(page));\n  if (limit) params.append('limit', String(limit));\n  \n  const query = params.toString();\n  const path = `/api/v1/tasks${query ? `?${query}` : ''}`;\n  return await makeRequest('GET', path);\n}\n\n/**\n * Execute env.fake_tasks_update_run_v1\n * Update an existing task by ID\n */\nexport async function runFakeTasksUpdate(input: any): Promise<any> {\n  const { task_id, ...updates } = input;\n  if (!task_id) {\n    throw new Error('task_id is required');\n  }\n  \n  return await makeRequest('PATCH', `/api/v1/tasks/${task_id}`, updates);\n}\n\n// Main router function\n// TODO: Implement envelope routing logic based on envelope_id\n",
        "notes": "Main runtime code - review TODOs before first run"
      }
    ],
    "design_notes_md": "## Code Structure\n\n- Each envelope has a dedicated async function (`runFakeTasksCreate`, `runFakeTasksList`, `runFakeTasksUpdate`)\n- Common `makeRequest` helper handles HTTP calls with auth\n- Environment variables used for API URL and token (never hardcoded)\n- Error handling is basic; TODO comments indicate where to add custom Error classes\n- Rate limit handling not yet implemented (see TODOs)\n\n## Assumptions\n\n- API uses Bearer token authentication\n- All endpoints return JSON\n- Errors are returned as HTTP status codes\n\n## Next Steps\n\n1. Implement custom Error classes for different error types\n2. Add retry logic for transient failures\n3. Add rate limit handling\n4. Add request/response logging (without secrets)",
    "checklist_for_human": [
      "Review the generated code and TODO sections",
      "Set FAKETASKS_API_URL and FAKETASKS_API_TOKEN environment variables",
      "Implement custom Error classes for better error handling",
      "Add tests for each envelope function (runFakeTasksCreate, runFakeTasksList, runFakeTasksUpdate)",
      "Run `npm run build` to compile TypeScript",
      "Test the code with sample inputs before production use"
    ]
  }
}

